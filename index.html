<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Feb 1997">
<meta property="og:url" content="http://xiaokeliu666.github.io/index.html">
<meta property="og:site_name" content="Feb 1997">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feb 1997">
  <link rel="canonical" href="http://xiaokeliu666.github.io/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Feb 1997</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feb 1997</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Overtime and overdue</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/23/HashMap的底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/23/HashMap的底层实现/" class="post-title-link" itemprop="url">HashMap的底层实现</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-23 20:17:31" itemprop="dateCreated datePublished" datetime="2019-09-23T20:17:31-04:00">2019-09-23</time>
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/20/LeetCode-1-Two-Sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/20/LeetCode-1-Two-Sum/" class="post-title-link" itemprop="url">LeetCode: 1.Two Sum</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-20 23:01:00" itemprop="dateCreated datePublished" datetime="2019-09-20T23:01:00-04:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-22 12:50:47" itemprop="dateModified" datetime="2019-09-22T12:50:47-04:00">2019-09-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h1 id="Wrong-Code"><a href="#Wrong-Code" class="headerlink" title="Wrong Code"></a>Wrong Code</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i =0; i &lt;nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">            if(hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[0] = i;</span><br><span class="line">                res[1] = hashMap.get(target-nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-Information"><a href="#Error-Information" class="headerlink" title="Error Information"></a>Error Information</h2><p>When nums= [3, 3], target = 6，expected outcome is[0, 1]，but [1, 1].</p>
<h2 id="Wrong-thinking"><a href="#Wrong-thinking" class="headerlink" title="Wrong thinking"></a>Wrong thinking</h2><p>I was trying to store the array into a hashmap. Considering that hashmap can only get value from key, so I put the value of array at the place of K while incremental i is V.<br>Then reason why I was wrong was not considering the situation of repeated numbers. During the debugging I found that the size of hashMap is 1 when the nums=[3,3] which means key is unique in hashMap.</p>
<h1 id="How-Did-I-Correct-the-Code"><a href="#How-Did-I-Correct-the-Code" class="headerlink" title="How Did I Correct the Code"></a>How Did I Correct the Code</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>The key of making mistake is ignoring the situation of repeated numbers in array, so directely transform array into hashmap by reversing the index to value  is not feasible since the repeated numbers won’t be stored twice in hashmap as a key.</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Given that the input would have exactly one solution, and the same element won’t be used twice, situation like multi-resolution and non-resolution will not be considered.<br>Because hashMap can get value by key, we still need hashmap to do this but in another way.<br>Instead of transforming the array into hashmap one time, I decide to use <code>hashMap.containskey(target-nums[i])</code> to search the hashmap, if returns false, then I put this number into the hashmap instead, otherwise we can get the right answer.<br>If the number is repeated but still cannot find the answer, then it means the resolution is not unique which doesn’t obey the rule of question. For example: nums = [3, 3, 6], target = 9. Obviously, the solution is not unique.</p>
<h2 id="Right-Code"><a href="#Right-Code" class="headerlink" title="Right Code"></a>Right Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[0] = hashMap.get(target - nums[i]);</span><br><span class="line">                res[1] = i;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                hashMap.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/17/Java：valueOf-方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/17/Java：valueOf-方法/" class="post-title-link" itemprop="url">Java：valueOf()方法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-17 21:20:45 / 修改时间：21:36:26" itemprop="dateCreated datePublished" datetime="2019-09-17T21:20:45-04:00">2019-09-17</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 这里应该输出两个true，实际输出的却是两个false</span><br><span class="line">        // 请查找、思考并修复numberEquals方法中的问题</span><br><span class="line">        System.out.println(numberEquals(&quot;1234&quot;, &quot;+1234&quot;));</span><br><span class="line">        System.out.println(numberEquals(&quot;1234&quot;, &quot;1234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断两个字符串是否包含相等的数字</span><br><span class="line">    // 例如a为&quot;+1234&quot;，b为&quot;1234&quot;，返回true</span><br><span class="line">    public static boolean numberEquals(String a, String b) &#123;</span><br><span class="line">        return Integer.valueOf(a) == Integer.valueOf(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>通过查看valueOf()方法的源码查看方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果输入的整型参数在[IntegerCache.low, IntegerCache.high]中，那么直接从缓存中拿，反之new Integer()。这一点在将源代码中的<code>1234</code>都改成<code>123</code>后输出两个true后得到了证实</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>把valueOf()方法替换成parseInt()方法即可，parseInt()返回的是基本类型int。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/16/Python踩坑：Pycharm中使用Pytorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/16/Python踩坑：Pycharm中使用Pytorch/" class="post-title-link" itemprop="url">Python踩坑：Pycharm中使用Pytorch</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-16 20:44:47 / 修改时间：20:55:30" itemprop="dateCreated datePublished" datetime="2019-09-16T20:44:47-04:00">2019-09-16</time>
            </span>
          
            

            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>尝试使用<code>pip install pytorch</code>指令在pycharm中使用Pytorch框架失败</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>在anaconda中使用<code>conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</code>指令安装pytorch后，再在Pycharm中创建新project的时候使用anaconda的环境即可</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>最近Anaconda官网上好像只能下载到3.7版本的了，所以在此之前我创建了一个版本为3.6的虚拟环境(py36)，因此在创建project时导入anaconda的环境需要导入虚拟环境目录下的python文件（D:\Anaconda3\envs\py36\python.exe）</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/07/Java：静态代码块、构造代码块、构造函数以及Java类初始化顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/07/Java：静态代码块、构造代码块、构造函数以及Java类初始化顺序/" class="post-title-link" itemprop="url">Java：静态代码块、非静态代码块、构造函数以及Java类初始化顺序</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-07 12:13:46 / 修改时间：14:06:16" itemprop="dateCreated datePublished" datetime="2019-09-07T12:13:46-04:00">2019-09-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>&emsp;&emsp;今天在做笔试题时遇到这样一个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        static Test t1 = new Test();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockB&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test t2 = new Test();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在以上代码中涉及到了静态代码块、构造代码块，之前没接触过这个概念，所以查资料记录学习了一下。</p>
<h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><h2 id="什么是静态代码块？"><a href="#什么是静态代码块？" class="headerlink" title="什么是静态代码块？"></a>什么是静态代码块？</h2><p>写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="它有什么特点？"><a href="#它有什么特点？" class="headerlink" title="它有什么特点？"></a>它有什么特点？</h2><ul>
<li>用static申明，JVM加载类时执行，仅执行一次，执行完成便销毁。</li>
<li>静态代码块的执行优先级高于非静态的初始化块。</li>
</ul>
<h1 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h1><h2 id="什么是非静态代码块？"><a href="#什么是非静态代码块？" class="headerlink" title="什么是非静态代码块？"></a>什么是非静态代码块？</h2><p>写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="它有什么特点？-1"><a href="#它有什么特点？-1" class="headerlink" title="它有什么特点？"></a>它有什么特点？</h2><p>&emsp;&emsp;执行的时候如果有非静态代码块，先执行静态代码块再执行非静态代码块，它可以初始化类的实例变量。非静态初始化块会在构造函数执行时，构造函数主体代码执行之前被运行。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>&emsp;&emsp;构造函数只有在建立对象的时候在会调用与之相应的构造函数，不建立对象是不会运行构造函数的。一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>静态块其实就是给类初始化的，而构造代码块是给对象初始化的。</li>
<li>静态代码块只会运行一次</li>
<li>静态块中的变量是局部变量，与普通函数中的局部变量性质没有区别。</li>
<li>一个类中可以有多个静态代码块，执行顺序按照位置决定。</li>
<li>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法</li>
</ol>
<hr>
<p>回到上面的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        static Test t1 = new Test();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockB&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test t2 = new Test();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockA</span><br><span class="line">blockB</span><br><span class="line">blockA</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>&emsp;&emsp;t1也是静态变量，所以按照声明顺序执行，先创建对象t1，运行其构造代码块，输出blockA，之后运行静态代码块，输出blockB，最后运行main函数。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/09/06/Java：接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/06/Java：接口/" class="post-title-link" itemprop="url">Java：接口</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-06 23:58:28 / 修改时间：23:58:56" itemprop="dateCreated datePublished" datetime="2019-09-06T23:58:28-04:00">2019-09-06</time>
            </span>
          
            

            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>接口可以解决Java不能多继承的问题</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/31/Java：前期绑定和后期绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/31/Java：前期绑定和后期绑定/" class="post-title-link" itemprop="url">Java：前期绑定和后期绑定</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-31 20:29:20" itemprop="dateCreated datePublished" datetime="2019-08-31T20:29:20-04:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-01 21:17:04" itemprop="dateModified" datetime="2019-09-01T21:17:04-04:00">2019-09-01</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="程序绑定"><a href="#程序绑定" class="headerlink" title="程序绑定"></a>程序绑定</h2><p>&emsp;&emsp;绑定指的是一个方法的调用与方法所在的类（方法主体）关联起来。对Java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。</p>
<h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>&emsp;&emsp;编译器在编译的时候就能解析的绑定叫做静态绑定或者前期绑定，Java当中的方法只有final，static和private方法是前期绑定。</p>
<p><strong>为什么static,final和private方法总是静态绑定的？</strong><br>&emsp;&emsp;静态绑定在性能方面更好（不需要额外开销）。编译器知道这些方法不能被重写并且一直都可以被本地类的对象访问。因此编译器很轻松就能确定类的对象（肯定是本地类），所以被这种方法绑定是静态的。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class NewClass &#123;</span><br><span class="line">    public static class superclass &#123;</span><br><span class="line">        static void print()&#123;</span><br><span class="line">            System.out.println(&quot;print in superclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class subclass extends superclass &#123;</span><br><span class="line">        static void print() &#123;</span><br><span class="line">            System.out.println(&quot;print in subclass.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        superclass A = new superclass();</span><br><span class="line">        superclass B = new subclass();  // 如果把此处的引用改成subclass，输出的就是&quot;print in subclass&quot;</span><br><span class="line">        A.print();</span><br><span class="line">        B.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in superclass</span><br><span class="line">print in superclass</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>我们创建了一个subclass的对象和一个superclass的对象，并且引用了superclass</li>
<li>superclass的print方法是静态的，编译器知道它不会在子类中被重写，因此编译器在编译期间知道要调用哪种打印方法，因此不存在歧义</li>
</ul>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>&emsp;&emsp;在动态绑定中编译器不决定调用的方法，因为对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。重写是动态绑定的一个完美例子。在重写中子类和父类都有同样的方法。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class NewClass &#123;</span><br><span class="line">    // 和上一个代码的区别在于print()方法不再static了</span><br><span class="line">    public static class superclass &#123;</span><br><span class="line">        void print()&#123;</span><br><span class="line">            System.out.println(&quot;print in superclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class subclass extends superclass &#123;</span><br><span class="line">        void print() &#123;</span><br><span class="line">            System.out.println(&quot;print in subclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        superclass A = new superclass();</span><br><span class="line">        superclass B = new subclass();</span><br><span class="line">        A.print();</span><br><span class="line">        B.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in superclass</span><br><span class="line">print in subclass</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>这个代码中的方法不是静态的</li>
<li>编译过程中，编译器不知道哪一个print方法被调用了，因为编译器只通过引用变量而不是对象类型来引用，于是绑定会被延迟到运行时而且因此对应版本的print会被根据对象类型调用</li>
</ul>
<p><strong>重点</strong></p>
<ul>
<li>private, final和静态成员（方法和变量）用静态绑定，然而对虚拟方法（Java方法默认为虚拟方法）绑定是在运行时基于运行时对象完成的</li>
<li>静态绑定使用类型信息用于绑定然而动态绑定用对象来解析绑定</li>
<li>重载方法通过静态绑定被解析（当有很多个同名方法时决定调用哪一个）然而重写方法用动态绑定</li>
</ul>
<hr>
<p>Q：<br>以下代码中发生了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Animal is eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Dog is eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">    Animal a=new Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A：<br>这个例子是一个动态绑定，因为a的类型实在运行时被确定的，于是相似的方法被调用了<br>现在假设有以下两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void callEat(Animal animal) &#123;</span><br><span class="line">    System.out.println(&quot;Animal is eating&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void callEat(Dog dog) &#123;</span><br><span class="line">    System.out.println(&quot;Dog is eating&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把main方法改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">    Animal a = new Dog();</span><br><span class="line">    callEat(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出会是<code>Animal is eating</code>，因为对<code>callEat</code>的调用是静态绑定，编译器只知道a是一种Animal。</p>
<hr>
<p>参考</p>
<blockquote>
<p><a href="https://www.geeksforgeeks.org/static-vs-dynamic-binding-in-java/" target="_blank" rel="noopener">Geeksforgeeks</a><br><a href="https://stackoverflow.com/questions/16647590/static-binding-and-dynamic-binding" target="_blank" rel="noopener">stackoverflow</a></p>
</blockquote>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/30/Java：多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/30/Java：多态/" class="post-title-link" itemprop="url">Java：多态</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-30 21:28:08" itemprop="dateCreated datePublished" datetime="2019-08-30T21:28:08-04:00">2019-08-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-06 16:42:48" itemprop="dateModified" datetime="2019-09-06T16:42:48-04:00">2019-09-06</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>这几天把《Java编程思想》中的第八章多态看了几遍，感觉相比其它两大特性（封装、继承）而言，多态更抽象，更难理解，运用起来更加灵活，当然这只是我目前而言的感受，在以后可能会有更深入的理解，现在能做的只有先把书中学到的东西先记录下来巩固一下，以后有新的收获再更新。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。<br>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一个基类导出来的，多态也称作动态绑定、后期绑定或运行时绑定。</p>
<h1 id="向上整型"><a href="#向上整型" class="headerlink" title="向上整型"></a>向上整型</h1><p>对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。把某个对象的引用视为对其基类型的引用的做法被称作向上转型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Instrument &#123;</span><br><span class="line">    // 基类乐器，方法play()</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        // 输出&quot;Instrument.play()&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Wind extends Instrument &#123;</span><br><span class="line">    // 管乐器类继承乐器基类，并重写了play()方法</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        // 输出&quot;Wind.play()&quot; + n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Music &#123;</span><br><span class="line">    public static void tune(Instrument i) &#123;</span><br><span class="line">        // tune()方法：乐器对象调用play()，默认参数为Note.MIDDLE_C</span><br><span class="line">        i.play(Note.MIDDLE_C)</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wind flute = new Wind();</span><br><span class="line">        tune(flute); //向上转型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>Music类中的tune()方法的参数列表中接受的参数是乐器类的对象，但是主函数中我们传入的对象是Wind类的，但是仍然输出了正确的结果，这就是向上转型的多态。从Wind向上转型到Instrument可能会”缩小“接口，但不会比Instrument的全部接口更窄。</p>
<h2 id="仅接受基类"><a href="#仅接受基类" class="headerlink" title="仅接受基类"></a>仅接受基类</h2><p>首先我们梳理一下上例：1.tune()方法接受的对象为Instrument类型对象；2.主函数中传入的对象为Wind类。<br>基于上述例子中我们可以想象，如果Instrument的子类有很多个的话，如果要实现同样的功能，会多出很多代码量并且代码看上去会非常的冗杂：我们要给各个子类单独创造对象，然后分别传入tune()方法。这样的代码会有很大一部分是类似的，因此我们会想办法：我们能不能写一个方法，仅接受基类作为参数，而不是子类。也就是说，如果我们不管子类的存在，编写的代码只与基类打交道会不会更好呢？<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Shape &#123;</span><br><span class="line">    public void draw() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        // 输出&quot;Circle.draw()&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Square extends Shape &#123;</span><br><span class="line">    // 同上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Triangle extends Shape &#123;</span><br><span class="line">    // 同上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RandomShapeGenerator &#123;</span><br><span class="line">    private Random rand = new Random(47);</span><br><span class="line">    public Shape next() &#123;</span><br><span class="line">        switch(rand.nextInt(3)) &#123;</span><br><span class="line">            default:</span><br><span class="line">            case 0: return new Circle();</span><br><span class="line">            case 1: return new Square();</span><br><span class="line">            case 2: return new Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Shapes &#123;</span><br><span class="line">    private static RandomShapeGenerator gen = new RandomShapeGenerator();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape[] s = new Shape[9];</span><br><span class="line">        for(int i = 0; i &lt; s.length; i++)</span><br><span class="line">            s[i] = gen.next();</span><br><span class="line">        for(Shape shp : s)</span><br><span class="line">            shp.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Triangle.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Circle.draw()</span><br></pre></td></tr></table></figure></p>
<p>分析：三个子类（Triangle,Circle,Sauqre）继承自一个基类（Shape）。RandomShapeGenerator类中的next()方法负责生成不同子类对象并最终返回一个Shape类型的对象（这其中包括了一个向上转型的过程在return里）。因此当我们在主函数中调用next()方法时，只能获得一个Shape的引用，是不知道具体是哪个子类的，主函数中通过调用next()方法随机生成9个对象并且装进Shape类型的数组中，然后让数组中的每个对象执行draw()方法。通过分析输出我们很容易就能得出结论，与子类型有关的特定行为正确地发生了。<br>结论：在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。（第一个代码的例子中，把<code>Wind flute = new Wind()</code>改成<code>Instrument flute = new Wind()</code>也能获得正确结果）</p>
<h2 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h2><p>之前举的例子都只有一层继承，除了Instrument外，都是它的子类。现在我们添加一层继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Woodwind extends Wind &#123;</span><br><span class="line">    void play(Note n) &#123;</span><br><span class="line">        System.out.println(&quot;Woodwind.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数中执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instrument woodwind = new Woodwind();</span><br><span class="line">tune(woodwind);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FakeWind.play()MIDDLE_C</span><br></pre></td></tr></table></figure></p>
<p>分析：多层继承并不会影响结果的正确输出。<br>总结：我们所做的代码修改，不会对程序中其他不应受到影响的部分产生破坏。换句话说，多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><h2 id="覆盖私有方法"><a href="#覆盖私有方法" class="headerlink" title="覆盖私有方法"></a>覆盖私有方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class PrivateOverride &#123;</span><br><span class="line">    private void f() &#123;</span><br><span class="line">        System.out.println(&quot;private f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PrivateOverride po = new Derived();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Derived extends PrivateOverride &#123;</span><br><span class="line">    public void f() &#123;</span><br><span class="line">        System.out.println(&quot;public f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private f()</span><br></pre></td></tr></table></figure></p>
<p>分析：Derived类为PrivateOverride类的子类，并且尝试重写f()方法。主函数中用PrivateOverride引用指向一个Derived对象，根据之前的向上转型原则，我们期待的输出应该是”public f()”，但是输出是”private f()”。原因在于private方法被自动认为是final方法，而且对导出类是屏蔽的。因此，在这种情况下，Derived类中的f()方法就是一个全新的方法；既然基类中的f()方法在子类Derived中不可见，因此也不能被重载。<br>结论：只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切的说，在导出类中，对于基类中的private方法，最好采用不同的名字。<br>思考：如果想达到期望输出，可以把基类中的f()方法改成public或者private，这样子类就可以覆盖。或者把子类中的f()方法改名，并且在主函数中重新调用即可。</p>
<h2 id="域与静态方法"><a href="#域与静态方法" class="headerlink" title="域与静态方法"></a>域与静态方法</h2><p>只有普通的方法调用是可以多态的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">    public int field = 0;</span><br><span class="line">    public int getField() &#123;return field;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Super &#123;</span><br><span class="line">    public int field = 1;</span><br><span class="line">    public int getField() &#123;return field;&#125;</span><br><span class="line">    public int getSupperField() &#123; return super.field;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FieldAccess &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super sup = new Sub();</span><br><span class="line">        System.out.println(&quot;sup.field = &quot; + sup.field + &quot;, sup.getField() = &quot; + sup.getField());</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        System.out.println(&quot;sub.field = &quot; + sub.field + &quot;, sub.getField() = &quot; + sub.getField() + &quot;, sub.getSupperFiled() = &quot; + sub.getSupperField());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sup.field = 0, sup.getField() = 1</span><br><span class="line">sub.field = 1, sub.getField() = 1, sub.getSupperFiled() = 0</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>在Java中，成员变量是静态绑定因为Java不允许对成员变量执行多态操作。<br>当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的（多态是在运行过程中进行动态绑定）。在这个例子中，虚拟机为Super.field和Sub.field分配了不同的存储空间(在堆内存中)。这样，Sub实际上包含两个称为field的域。然而，在引用Sub中的field时所产生的默认域并非Super版本的域。因此，为了得到Super.field，必须显示的指明super.field。<br>总结：<br>以上这种访问方法无疑是非常易混淆的，因此实际开发中通常会将所有的域都设置成private。</p>
<p>另外一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class StaticSupper &#123;</span><br><span class="line">    public static String staticGet() &#123;</span><br><span class="line">        return &quot;Base staticGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String dynamicGet() &#123;</span><br><span class="line">        return &quot;Base dynamicGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StaticSub extends StaticSupper &#123;</span><br><span class="line">    public static String staticGet() &#123;</span><br><span class="line">        return &quot;Derived staticGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String dynamicGet() &#123;</span><br><span class="line">        return &quot;Derived dynamicGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StaticPolymorphism &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StaticSupper sup = new StaticSub();</span><br><span class="line">        System.out.println(sup.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base staticGet()</span><br><span class="line">Derived dynamicGet()</span><br></pre></td></tr></table></figure></p>
<p>分析：基类中的staticGet()方法是静态方法，dynamicGet是非静态方法，从结果中可以看出子类并没有覆盖基类中的静态方法。<br>总结：静态方法是与类，而并非与单个的对象相关联的。</p>
<h1 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h1><p>构造器不具有多态性，因为它们实际上是static方法，只不过该static声明式隐式的。</p>
<h2 id="构造器的调用顺序"><a href="#构造器的调用顺序" class="headerlink" title="构造器的调用顺序"></a>构造器的调用顺序</h2><p>基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Meal &#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(&quot;Meal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bread &#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(&quot;Bread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cheese &#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(&quot;Cheese&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lettuce &#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(&quot;Lettuce&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lunch extends Meal &#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(&quot;Lunch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PortableLunch extends Lunch &#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(&quot;PortableLunch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sandwich extends PortableLunch&#123;</span><br><span class="line">    Sandwich() &#123;</span><br><span class="line">        System.out.println(&quot;Sandwich&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private Bread b = new Bread();</span><br><span class="line">    private Cheese c = new Cheese();</span><br><span class="line">    private  Lettuce l = new Lettuce();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meal</span><br><span class="line">Lunch</span><br><span class="line">PortableLunch</span><br><span class="line">Bread</span><br><span class="line">Cheese</span><br><span class="line">Lettuce</span><br><span class="line">Sandwich</span><br></pre></td></tr></table></figure></p>
<p>分析&amp;总结：从输出中验证结论，调用构造器要遵照下面的顺序：</p>
<ol>
<li>调用基类构造器。这个步骤会不断地反复地递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最低层的导出类。</li>
<li>按声明顺序调用成员的初始化方法。</li>
<li>调用导出类构造器的主体。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/29/Java：is-a和has-a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/29/Java：is-a和has-a/" class="post-title-link" itemprop="url">Java：is-a和has-a</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-29 10:41:34 / 修改时间：15:13:02" itemprop="dateCreated datePublished" datetime="2019-08-29T10:41:34-04:00">2019-08-29</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>之前讨论过Java的代码复用问题，其中提到了组合、继承和代理三中复用方法。在进一步了解这三种方法的使用场景时，首先需要鉴别类之间的关系。</p>
<h1 id="is-a"><a href="#is-a" class="headerlink" title="is-a"></a>is-a</h1><p>is-a：该关系依赖于继承。如果A是B，那么B就是A的基类。<br>比如土豆是蔬菜，公交车是载具，灯泡是电器等等。继承的一个性质就是继承是单向的，比如说公寓是建筑物，但是不是所有建筑物都是公寓。</p>
<h1 id="has-a"><a href="#has-a" class="headerlink" title="has-a"></a>has-a</h1><p>has-a：这种关系称为组合。如果A中有B，那么B就是A的组成部分。<br>一个类的实例有指向另一个类的索引或者同一个类的其他实例。比如汽车有引擎，狗有尾巴等等。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/27/Java：代码复用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/27/Java：代码复用/" class="post-title-link" itemprop="url">Java：代码复用</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-27 21:06:22" itemprop="dateCreated datePublished" datetime="2019-08-27T21:06:22-04:00">2019-08-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:04:19" itemprop="dateModified" datetime="2019-08-29T15:04:19-04:00">2019-08-29</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。<br>&emsp;&emsp;实现代码复用的第一种方法：只需在新的类中产生现有类的对象。由于新的类是由现有类的对象所组成，所以这种方法称为组合。<br>&emsp;&emsp;实现代码复用的第二种方法：按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种方式称为<strong>继承</strong>。</p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>&emsp;&emsp;将对象引用置于新类中即可。例如我现在有两个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Wheel &#123;</span><br><span class="line">    void run()&#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);  // 车轮类的功能是run</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Light &#123;</span><br><span class="line">    void lit() &#123;</span><br><span class="line">        System.out.println(&quot;lit&quot;);  // 车灯类的功能是lit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我现在有一个新的类Car，需要同时有run和lit的功能，此时应当使用组合，这样我就可以在Car类中同时拥有两个类的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    private Wheel wheel;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public Car(Wheel wheel, Light light) &#123;</span><br><span class="line">        this.wheel = wheel;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        wheel.run();</span><br><span class="line">        light.lit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wheel wheel = new Wheel();</span><br><span class="line">        Light light = new Light();</span><br><span class="line">        Car car = new Car(wheel, light);</span><br><span class="line">        car.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="继承与代理"><a href="#继承与代理" class="headerlink" title="继承与代理"></a>继承与代理</h1><p>&emsp;&emsp;Java中的继承是一个类继承另一个类的性质的过程。比如一个新的类我们称之为衍生类或子类，继承了之前就存在的我们称之为父类、超类或者基类的类的属性和行为。<br>&emsp;&emsp;代理仅仅是把任务传递给别的类。</p>
<ul>
<li>代理可以是继承的替代品</li>
<li>代理意味着你将其他类的对象作为实例变量传递信息给指定的实例</li>
<li>很多情况下代理比继承好因为代理让你去考虑你所传递的每个信息，因为实例属于一个已知的类而不是一个新的类，并且不强迫你去接受父类的所有方法：你可以只提供有用的方法</li>
<li>代理可以被看作对象之间的关系因为一个对象转发相应的方法调用给另一个对象，这叫做代理</li>
<li>代理的主要优势是运行时间的灵活性——代理可以很容易地改变运行时间。但是和继承不同，代理并不被主流的面向对象语言所支持，而且它不易于动多态。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class RealPrinter&#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(&quot;The delegate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Printer &#123;</span><br><span class="line">    RealPrinter p = new RealPrinter();</span><br><span class="line"></span><br><span class="line">    void print() &#123;</span><br><span class="line">        p.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Tester &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Printer printer = new Printer();</span><br><span class="line">        printer.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The delegate</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当使用代理时，只需要调用一些必须要用的类，不用关心是怎么实现的，只需要知道你调用的那个类知道要做什么。<br>&emsp;&emsp;同样的代码用继承来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class RealPrinter &#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(&quot;Printing Data&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Printer extends RealPrinter &#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        super.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Tester &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Printer printer = new Printer();</span><br><span class="line">        printer.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Printing Data</span><br></pre></td></tr></table></figure></p>
<p>什么时候该用什么？<br>这里举几个例子来说明什么时候用代理什么时候用继承：<br>假设你的类叫B，是A的子类，那么如果：</p>
<ul>
<li>你想表达(is-a)关系，用继承</li>
<li>你想把类直接传递到一个现有的需要A的API那么就用继承</li>
<li>你想改进A，但是A已经是终点并且不能再被继承了，那你就要用组合和代理</li>
</ul>
<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>&emsp;&emsp;首先想一想，组合是怎么工作的。我们把对象引用放在新的类里，这就意味着我们可以通过组合语法，在一个类中拥有多个指向其他类的引用。<br>&emsp;&emsp;其次想一想继承是如何工作的，继承通过extends关键词，可以接过父类中所有的属性和方法，但是由于Java是不支持多继承的，所以一个类只能继承一个父类。<br>&emsp;&emsp;根据特性我们可以总结一下继承和组合的优缺点：<br><strong>继承</strong><br>优点：</p>
<ul>
<li>支持扩展；</li>
<li>被复用的代码易于修改</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类的实现细节都暴露给了子类，破坏了封装性；</li>
<li>当父类代码修改时，子类也要修改，增加了维护的难度；</li>
<li>子类缺乏独立性，与父类的耦合度高；</li>
<li>不支持动态拓展，在编译期就决定了父类。</li>
</ul>
<p><strong>组合</strong><br>优点：</p>
<ul>
<li>被包括的对象内部实现细节对外不可见，封装性好；</li>
<li>整体类与局部类松耦合，相互独立；</li>
<li>支持扩展；</li>
<li>每个类只负责一项业务；</li>
<li>支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建整体类对象时，需要创建所有局部类对象。导致系统对象很多。    </li>
</ul>
<p>&emsp;&emsp;关于代理，《Java编程思想》中对代理有这样一句描述：这是继承与组合之间的中庸之道。在代理类中可以创建某功能的类，调用类的一些方法获得该类的部分特性。比如说我有一个飞机类，飞机有向各个方向运动的方法，还有发射导弹的方法。我可以通过在代理类中只调用（就像组合）运动方法的方法来避免暴露发射导弹的方法，同时代理类中暴露了其他运动的方法（就像继承）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/riskys/article/details/54988442" target="_blank" rel="noopener">csdn</a></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="Feb 1997">
  <p class="site-author-name" itemprop="name">Feb 1997</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feb 1997</span>
</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>


  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  





  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
































</body>
</html>
