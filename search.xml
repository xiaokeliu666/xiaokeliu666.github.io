<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Djangos学习笔记：上传文件/图片</title>
    <url>/2019/08/09/Djangos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>&emsp;&emsp;首先在根目录下的settings中添加配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, &apos;media&apos;)</span><br><span class="line">MEDIA_URL = &apos;/media/&apos;</span><br></pre></td></tr></table></figure></p>
<p>这样上传的文件就会在media文件夹中</p>
<p>&emsp;&emsp;Models.py中添加模型并完成迁移，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ImageStore(models.Model):</span><br><span class="line">    name = models.CharField(max_length=150, null=True)</span><br><span class="line">    img = models.ImageField(upload_to=&apos;img&apos;)  # 会上传至/media/img文件夹中，如不存在则会自动生成一个</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上传图片功能需要安装Pillow:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后在admin.py中注册模型:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin.site.register(ImageStore)</span><br></pre></td></tr></table></figure></p>
<p>即可在管理员界面对图片进行上传，并且上传后图片会出现在文件夹中。</p>
<p>&emsp;&emsp;目前还存在的问题是无法在管理员界面显示图片，如果直接点链接会跳转至一个新的无法到达的地址，原因是因为相应的路由地址我还没写。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习笔记：模型搭建</title>
    <url>/2019/08/12/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>&emsp;&emsp;模型是一个用于表示数据的Python类，包含基本的数据字段和行为，在Django中，通常一个模型就代表一个数据库表。模型继承自django.db.models.Model, 模型的每一个属性代表一个数据表的列。<br>&emsp;&emsp;例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=30)</span><br><span class="line">    last_name = models.CharField(max_length=30)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是django根据模型所属应用程序生成数据库表明，命名规则：<strong>应用程序名_模型名</strong>，Django会自动添加id字段作为数据库表的主键。</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>&emsp;&emsp;个人对模型部分的理解是对数据库的操作，models.py文件中的所有操作都可以找到与之对应的数据库操作，只不过有特有的字段名称。而在编辑好模型后进行的数据迁移操作实际上就是将models.py里面的翻译成脚本，然后通过执行脚本文件对数据库进行操作从而生成当前APP所需要用到的数据库。</p>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>&emsp;&emsp;字段是一系列数据表列的定义。字段名字中不能出现连续的两个下划线，因为连续的两个下划线是Django数据库API的特殊语法。</p>
<h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><ol>
<li>AutoField<br>根据已有的ID自动增长，常用作主键，一般情况下会自动创建。</li>
<li>BooleanField<br>字段值只包含True和False，默认情况下对应HTML的复选框：<input type="checkbox" ...></li>
<li>CharField<br>保存不太长的字符串（超长字段建议使用TextField）。必须给出CharField.max_length属性值，默认情况下对应HTML的文本框：<input type="text" ...>。</li>
<li>DateField<br>日期类型，对应Python中的datetime.date类型。参数有：<br>auto_now:每当保存数据(Save())时都会更新时间为当前时间且不能被重写。<br>auto_now_add: 只有在数据第一次创建时才会保存当前时间且不能被重写。</li>
<li>DateTimeField<br>日期时间类型，对应Python中的datetime.datetime类型，参数与DateField一样。默认情况下对应HTML的复选框：<input type="checkbox" ...>。</li>
<li>EmailField<br>可以验证有效邮件地址的CharField。</li>
<li>FileField<br>文件上传控件，可选参数：<br>upload_to：文件上传后保存位置（在settings.py中设置MEDIA_ROOT,upload_to所指定的路径会拼接在MEDIA_ROOT之后）<br>storage：负责文件存储的Python类，用于存储和提取文件。</li>
<li>ImageField<br>包含FileField的全部属性与方法，但是仅允许上传图片类型的文件，额外两个可选属性:<br>height_field: 高度<br>width_field: 宽度</li>
<li>TextField<br>超长文本类型</li>
<li>URLField<br>只接受URL字符串的CharField类型。</li>
</ol>
<h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><ol>
<li>null<br>&emsp;&emsp;默认为True，保存模型后数据库的对应字段中保存空。<br>&emsp;&emsp;文本型字段尽可能不用null属性，因为当时用默认值null时，数据库中就可能出现两种空数据：NULL和空字符串，而Django默认使用空字符串。</li>
<li>blank<br>默认值为False，当设置为True时字段值允许为空</li>
<li><p>choices<br>属性值为一个<strong>可迭代对象</strong>，如列表或元组，迭代对象的每个成员包括两个字符串，第一个值作为字段值保存到数据库中，第二个值用于提高字段的可读性。例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YEAR_IN_SCHOOL_CHOIECES = (</span><br><span class="line">    (&apos;FR&apos;, &apos;Freshman&apos;),</span><br><span class="line">    (&apos;SO&apos;, &apos;Sophomore&apos;),</span><br><span class="line">    (&apos;JR&apos;, &apos;Junior&apos;),</span><br><span class="line">    (&apos;SR&apos;, &apos;Senior&apos;),</span><br><span class="line">)  # 定义一个元组</span><br><span class="line"></span><br><span class="line">year_in_school = models.CharField(</span><br><span class="line">    max_length = 2,</span><br><span class="line">    choices = YEAR_IN_SCHOOL_CHOICES,  # 直接引用元组</span><br><span class="line">    default = &apos;Freshman&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>default<br>设置字段默认值。属性值可以是字符串也可以是方法。默认值<strong>不可以是可变对象</strong>，如列表。</p>
</li>
<li>primary_key<br>将字段设置为数据表主键。如果模型中任何字段都不包含primary_key=True属性，会自动添加一个字段作为主键。</li>
<li>verbose_name<br>类似于字段的说明。<br>除了ForeignKey、ManyToManyField、OneToOneField三种字段类型外，其他字段类型都包含一个默认的verbose_name属性，可以直接在字段属性列表的第一位输入文本作为verbose_name属性值，如未给出则会将字段名作为verbose_name（字段名如果包含下划线会换成空格）。<h2 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h2>模型对应数据库的表，那么字段就对应表的列。</li>
</ol>
<h1 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h1><p>通过在模型中添加一个叫做Meta的子类定义。</p>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p><code>abstract = True</code>，当前模型将成为一个抽象类。</p>
<h2 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h2><p>该属性是一个元组、列表或者查询表达式。定义了显示的顺序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;模型的构建对应数据库的构建，这次只记录了目前为止用过的一些知识，还有很多字段、属性、元属性尚未涉及，以后碰到了再继续补充。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django踩坑：python manage.py dbshell报错</title>
    <url>/2019/08/11/Django%E8%B8%A9%E5%9D%91-dbshell%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;之前为了避免麻烦，Django的数据库配置用的都是自带的sqlite，今天尝试用Pycharm进行数据库的可视化，但是sqlite好像用不了，而且网上的相关资料比较少，于是还是改用MySQL。<br>&emsp;&emsp;省略掉<code>settings.py</code>中对数据库的配置过程，最后在我新建模型并完成迁移操作后，我在pycharm的终端使用命令行<figure class="highlight python"><figcaption><span>manage.py dbshell```，出现错误信息:</span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">    CommandError: You appear <span class="keyword">not</span> to have the ‘mysql’ program installed <span class="keyword">or</span> on your path.</span><br></pre></td></tr></table></figure></p>
<p>大意是指路径中找不到mysql。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>&emsp;&emsp;找到Mysql所在的文件夹的bin目录，添加至系统环境变量的Path即可，例如：D:\mysql-5.7.27-winx64\bin<br>&emsp;&emsp;测试是否生效的方法就是打开CMD，输入<code>mysql -hroot -ppwd</code>即可直接进入数据库，其中root是用户名，pwd是密码。<br>&emsp;&emsp;最后一部是重启pycharm，我在没重启的之前还是会报错，应该是重启之后配置才生效的。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Django踩坑：python manage.py migrate报错</title>
    <url>/2019/08/01/Django%E8%B8%A9%E5%9D%91%EF%BC%9Apython-manage-py-migrate%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>&emsp;&emsp;在配置Django开发环境时，为了用到Django自带的数据模型，使用<code>python manage.py migrate</code>对数据进行迁移，所谓迁移，就是根据模型自动生成关系数据库中的二维表。</p>
<h1 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h1><p>在实际操作过程中我先后遇到如下两种报错信息:</p>
<ol>
<li><p>意思是说我的mysqlclient版本过低，但是我在退出虚拟环境后通过<code>pip list</code>检查出版本是最新的，进入虚拟环境后就显示不出来了，pip也不能用，尝试了网上各种方法无果，猜想可能是我虚拟环境的配置出了问题，我觉得如果不在虚拟环境内进行数据迁移的话可能不会有问题，但是毕竟虚拟环境是Python开发神器，还是很想把虚拟环境配置好。<br> Stackoverflow上有一个人针对这个错误提供了一个方案，大致的思路是对虚拟环境下的后台mysql文件进行修改，在版本检测这一环节对检测到低于1.3.13版本的mysqlclient采取直接pass的措施，不捕捉异常，经测试有效。具体操作过程见参考引用中的链接。<br> 最后通过virtualenvwrapper创建虚拟环境解决了问题，将所有的虚拟环境目录全都集中起来，比如放到 ~/Envs/，并对不同的虚拟环境使用不同的目录来管理。并且，它还省去了每次开启虚拟环境时候的 source 操作，使得虚拟环境更加好用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlclient 1.3.13 or newer is required; you have 0.9.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在第一个问题解决后，我在新的虚拟环境重新配置，同样进行到<code>python manage.py migrate</code>步骤时出现了如下问题，意思是说我的SQL语法有问题，但是因为当时我只进行了一步<code>CREATE database</code>的操作，并且操作成功，所以排除我SQL语句错误的可能性。后来了解到Django 2.0已经停止了对MySQL 5.5的支持，而我系统安装的MySQL正好是5.5版本的，于是尝试用MySQL 5.7替换，最后问题得到解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django.db.utils.ProgrammingError: (1064, &quot;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;(6) NOT NULL)&apos; at line 1&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><p><a href="https://stackoverflow.com/questions/55657752/django-installing-mysqlclient-error-mysqlclient-1-3-13-or-newer-is-required" target="_blank" rel="noopener">Stackoverflow</a></p>
<p><a href="https://www.jianshu.com/p/7ed2dfa86e90" target="_blank" rel="noopener">virtualenvwrapper的安装及使用</a></p>
<p><a href="https://blog.csdn.net/sxingming/article/details/52601250" target="_blank" rel="noopener">Windows10系统下，彻底删除卸载MySQL</a></p>
<hr>
<h2 id="更新-2019-08-04"><a href="#更新-2019-08-04" class="headerlink" title="更新(2019-08-04)"></a>更新(2019-08-04)</h2><p>&emsp;&emsp;之前的学习都是跟着Github上的<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100-Days</a>操作的，全程用命令行Vim操作，用了一段时间觉得操作不是很方便，今天重新用Pycharm操作Django项目，另外为了避免之前的问题用的是Django自带的Sqlite数据库而不是Mysql，一路下来很顺畅。另外个人觉得Python-100-Days的教程太过笼统，更适合作为一个学习路线和查漏补缺。</p>
<h2 id="参考引用-1"><a href="#参考引用-1" class="headerlink" title="参考引用"></a>参考引用</h2><p><a href="http://www.liujiangblog.com/course/django/" target="_blank" rel="noopener">刘江的博客教程</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Bit Manipulation</title>
    <url>/2020/07/07/Bit-Manipulation/</url>
    <content><![CDATA[<h1 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h1><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><div class="table-container">
<table>
<thead>
<tr>
<th>&amp;</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id><a href="#" class="headerlink" title="|"></a>|</h3><div class="table-container">
<table>
<thead>
<tr>
<th>\</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h3><div class="table-container">
<table>
<thead>
<tr>
<th>^</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h3><p>~   1 0 0 1 1<br>=&gt;  0 1 1 0 0</p>
<h3 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 8;</span><br><span class="line">a &lt;&lt; 3;</span><br><span class="line"></span><br><span class="line">before：0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">after：0000 0000 0000 0000 0000 0000 0100 0000</span><br></pre></td></tr></table></figure>
<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int a = 8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">before：0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">after：0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">​</span><br><span class="line">int a = -8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">before：1111 1111 1111 1111 1111 1111 1111 1000</span><br><span class="line">after：1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<h1 id="Common-Problem"><a href="#Common-Problem" class="headerlink" title="Common Problem"></a>Common Problem</h1><ol>
<li><p>Implement division</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">a &gt;&gt; <span class="number">1</span>; ---&gt; <span class="number">1</span></span><br><span class="line">a &lt;&lt; <span class="number">1</span>; ---&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Swap two digits</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">     a ^= b;</span><br><span class="line">     b ^= a;</span><br><span class="line">     a ^= b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Explaination:<br>Step 1：a ^= b —-&gt; a = (a^b);</p>
<p> Step 2：b ^= a —-&gt; b = b\^(a^b) —-&gt; b = (b\^b)^a = a</p>
<p> Step 3：a ^= b —-&gt; a = (a\^b)^a = (a\^a)^b = b</p>
</li>
<li><p>Odd or Even<br>If the last digit is 0, then even. Otherwise, odd</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == (a &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">    even</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Change the sign</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversal</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ~a + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Detect opposite sign</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oppositeSigns</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// -1 if opposite, 0 if not</span></span><br><span class="line">   <span class="keyword">return</span> ((x ^ y) &gt;&gt; <span class="number">31</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oppositeSigns</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1 if opposite, 0 if not</span></span><br><span class="line">   <span class="keyword">return</span> ((x ^ y) &gt;&gt;&gt; <span class="number">31</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>Django踩坑：PK</title>
    <url>/2019/08/08/Django%E8%B8%A9%E5%9D%91%EF%BC%9APK/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;在<a href="https://xiaokeliu666.github.io/2019/08/04/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AADjango%E5%BA%94%E7%94%A8/">《第一个Django应用》</a>中，我根据教程总结了我对于Django应用开发过程的初步理解以及对应用开发步骤的梳理，在我尝试仅根据博文内容对应用进行复现的过程中出现了如下错误：<br><a href="Django踩坑-PK/pk报错.png"></a><br>&emsp;&emsp;这个错误出现在我进入polls主页后选择其中一项标题进行投票时，投票结束后跳转到了<code>http://127.0.0.1:8000/polls/1/vote/</code>，本来按道理应该是<code>http://127.0.0.1:8000/polls/1/results/</code>，于是我将检查目标定在了/polls/views.py文件的vote()方法里，因为我在这个方法里设置了页面的跳转，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def vote(request, question_id):</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    try:</span><br><span class="line">        selected_choice = question.choice_set.get(request.POST[&apos;choice&apos;])</span><br><span class="line">    except (KeyError, Choice.DoesNotExist):</span><br><span class="line">        return render(request, &apos;polls/detail.html&apos;, &#123;</span><br><span class="line">            &apos;question&apos;: question,</span><br><span class="line">            &apos;error_message&apos;: &quot;You didn&apos;t select a choice.&quot;,</span><br><span class="line">            &#125;)</span><br><span class="line">    else:</span><br><span class="line">        selected_choice.votes += 1</span><br><span class="line">        selected_choice.save()</span><br><span class="line">        return HttpResponseRedirect(reverse(&apos;polls:results&apos;, args=(question.id,)))</span><br></pre></td></tr></table></figure></p>
<h1 id="分析解决"><a href="#分析解决" class="headerlink" title="分析解决"></a>分析解决</h1><p>&emsp;&emsp;结合报错信息’not enough values to unpack(excepted 2, got 1)’，意思是在解包过程中少了一个数值，通过检察源码找到get()方法的信息：Perform the query and return a single object matching the given keyword arguments.通过给定的关键词语句执行查询并返回匹配的对象。request.POST是一个类似字典的对象，允许你通过键名访问提交的数据。本例中，request.POST[’choice’]返回被选择选项的ID，而ID是主键，因此改为<code>pk=request.POST[&#39;choice&#39;]</code>即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;在创建一个新的models实例时，如果没有设置主键，那么Django会自动创建一个id字段作为该模型的主键，有时候用id和pk都能达到预期的效果，但是pk更加独立于真正的主键，也就是说不用在意主键是叫id或者是object_id。并且使用pk可以提高一致性，即便模型中有不同的主键。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://stackoverflow.com/questions/2165865/django-queries-id-vs-pk" target="_blank" rel="noopener">stackoverflow</a><br>李健.《Django 2.0入门与实践》.清华大学出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Django踩坑：数据迁移遇到的问题</title>
    <url>/2019/08/14/Django%E8%B8%A9%E5%9D%91%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;在学习过程中我在同一个APP（名为’tst’）下反复修改模型（注释旧的模型，创建新的模型），在创建新模型后尝试进行数据迁移，出现如下错误信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No migrations to apply</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在尝试从数据库中删除所有与tst相关的字段后再次尝试迁移：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1050, &quot;Table &apos;django_content_type&apos; already exists&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>&emsp;&emsp;造成多次应用migrations失败的原因是，当前model是修改过的，原来的migrations已经被我删除，但是，重新生成的migrations使用递增整数记名，所以，在django_migrations表中0001，0002等前面几个数字的文件都已被记录，在Django看来，被记录了就相当于已应用，所以，会出现刚开始的No migrations to apply.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&emsp;&emsp;python manage.py migrate —fake-initial<br>&emsp;&emsp;python manage.py makemigrations<br>&emsp;&emsp;python manage.py migrate</p>
<h1 id="关于—fake-initial和—fake"><a href="#关于—fake-initial和—fake" class="headerlink" title="关于—fake-initial和—fake"></a>关于—fake-initial和—fake</h1><h2 id="—fake-initial"><a href="#—fake-initial" class="headerlink" title="—fake-initial"></a>—fake-initial</h2><p>Allows Django to skip an app’s initial migration if all database tables with the names of all models created by all CreateModel operations in that migration already exist. This option is intended for use when first running migrations against a database that preexisted the use of migrations. This option does not, however, check for matching database schema beyond matching table names and so is only safe to use if you are confident that your existing schema matches what is recorded in your initial migration.</p>
<h2 id="—fake"><a href="#—fake" class="headerlink" title="—fake"></a>—fake</h2><p>Marks the migrations up to the target one (following the rules above) as applied, but without actually running the SQL to change your database schema.</p>
<p>This is intended for advanced users to manipulate the current migration state directly if they’re manually applying changes; be warned that using —fake runs the risk of putting the migration state table into a state where manual recovery will be needed to make migrations run correctly.</p>
<h1 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h1><blockquote>
<p><a href="https://blog.csdn.net/qq_25730711/article/details/60327344" target="_blank" rel="noopener">cdsn</a><br><a href="https://docs.djangoproject.com/en/2.2/topics/migrations/" target="_blank" rel="noopener">Django2.0官方文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Django：模型访问</title>
    <url>/2019/08/19/Django%EF%BC%9A%E6%A8%A1%E5%9E%8B%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Manager属性"><a href="#Manager属性" class="headerlink" title="Manager属性"></a>Manager属性</h1><p>&emsp;&emsp;Manager是Django模型最重要的属性，通过使用Manager模型才可以操作数据库。默认情况下，Django会为每一个模型提供一个名为objects的Manager实例。Manager属性只能通过模型类访问。</p>
<h2 id="自定义Manager类"><a href="#自定义Manager类" class="headerlink" title="自定义Manager类"></a>自定义Manager类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Blog(models.Model):</span><br><span class="line">&apos;&apos;&apos;模型的定义&apos;&apos;&apos;</span><br><span class="line">    name = models.CharField(max_length=100)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line">    blog = models.Manager()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure>
<p>上例中的<code>blog = models.Manager()</code>自定义Manager类(之前的情况是不加这一句的)，可以通过<code>Blog.blog.all()</code>查询数据，返回的结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Scott Blog&gt;]&gt;</span><br></pre></td></tr></table></figure></p>
<p>改进一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs = Blog.blog.all()</span><br><span class="line">for b in qs:</span><br><span class="line">    print(b.name)</span><br></pre></td></tr></table></figure></p>
<p>返回的结果是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Beatles Blog</span><br><span class="line">Scott Blog</span><br></pre></td></tr></table></figure></p>
<h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><ol>
<li>Manager.raw()<br>语法：Manager.raw(raw_query, params=None, translations=None)<br>针对同样的Blog模型<br>例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blogs = Blog.blog.raw(&quot;select * from tst_blog&quot;)  # 第一个blog是我在模型中将Manager()命名为blog，tst_blog是表</span><br><span class="line">for b in blogs:</span><br><span class="line">    print(b.name)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Beatles Blog</span><br><span class="line">Scott Blog</span><br></pre></td></tr></table></figure></p>
<p>注意：如果不能返回数据则会抛出异常</p>
<ol>
<li>django.db.connection<br>&emsp;&emsp;django.db.connection对象提供了数据库连接操作，使用connection.cursor()方法可以得到一个游标对象，cursor.execute(sql,[paramas])方法用于执行指定的SQL语句。使用cursor.fetchone()或者cursor.fetchall()方法可以得到一个或全部结果。<h1 id="表与表之间的关系"><a href="#表与表之间的关系" class="headerlink" title="表与表之间的关系"></a>表与表之间的关系</h1><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2>&emsp;&emsp;在关系型数据库中通常使用外键来表示多对一关系，Django模型中的ForeignKey字段就是模型的外键，写在“多”的那个模型下，其第一个参数对应相关联的类，例如一个问题可以有多个选项：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Question(models.Model):</span><br><span class="line">    content = models.CharField(max_length=128)</span><br><span class="line"></span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)  # on_delete=models.CASCADE属性必须设置，表示级联删除</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;以上代码在生成数据库时，Django会自动在Choice所对应的表中添加字段question_id作为外键。<br><strong>访问方法：</strong><br>前向查询：通过 Choice中的外键查询Question<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = Choice.objects.get(pk=1)</span><br><span class="line">c.question</span><br></pre></td></tr></table></figure></p>
<p>反向查询：通过Question查询Choice<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q = Question.objects.get(pk=1)</span><br><span class="line">q.choice_set.all()</span><br></pre></td></tr></table></figure></p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>&emsp;&emsp;假设公司里一个员工属于一个或多个部门，每个部门有一个或多个员工，为了实现该组织架构，使用ManyToManyField字段类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Department(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line"></span><br><span class="line">class Employee(models.Model):</span><br><span class="line">    departments = models.ManyToManyField(Department)  # 多对多字段名用复数</span><br><span class="line">    name = models.CharField(max_length=50)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意：可以在任一个模型中定义ManyToManyField，但是不能两个都定义。<br>对于多对多关系，Django会在数据库中额外创建一张关系表，关系表的命名规则是：应用程序名_模型1名_模型2名s，在上例中生成的表名为app_employee_departments<br>访问方法（类似反向查询）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d = Department.objects.get(id=3)</span><br><span class="line">d.Employee_set.all()</span><br></pre></td></tr></table></figure></p>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>&emsp;&emsp;使用OneToOneField表示一对一关系，第一个参数是模型名。这种关系用的少。</p>
]]></content>
  </entry>
  <entry>
    <title>HashMap面试题</title>
    <url>/2020/05/25/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h1><ol>
<li><p><strong>域变量</strong><br>默认初始大小：16<br>最大长度：1 &lt;&lt; 30<br>默认加载因子：0.75f<br>modCount: 对Map的iterator()操作做一致性校验，如果在iterator操作过程中，map的数值有修改，直接抛出<code>ConcurrentModiifcationException</code>异常<br>threshold: table.length * loadFactor。</p>
</li>
<li><p><strong>put()方法</strong></p>
<ul>
<li>如果Key为null，统一放在下标为0的bucket，即table[0]位置的链表，如果是第一次对key=null做put操作，将会在table[0]的位置新增一个Entry节点，使用头插法做链表插入。调用的是putForNullKey()方法:首先选择table[0]位置的链表，然后对链表做遍历操作，如果有节点的key为null，则用新值覆盖旧值，并且返回旧值，否则新增一个key为null的Entry节点。</li>
</ul>
</li>
<li><p><strong>扩容</strong></p>
<ul>
<li>扩容后的大小是扩容前的两倍</li>
<li>将数据从旧table迁移到扩容后的新table。为避免碰撞过多，先决策是否需要对每个Entry链表节点重新hash，然后根据hash值计算得到bucket下标，然后用头插法做节点迁移。</li>
</ul>
</li>
<li><p><strong>hash值的计算</strong></p>
<ul>
<li>使用key的hashCode作为算式(arithmetic)的输入，得到了hash值。</li>
<li>对于两个对象，如果hashCode相同，那么hash值就一定相同。</li>
<li>如果两个对象逻辑相等（内存地址相同），那么hashCode一定相等，反之不一定成立。</li>
</ul>
</li>
<li><p><strong>bucket下标的计算</strong></p>
<ul>
<li>取模：<code>h &amp; (length-1)</code> h为hashCode</li>
</ul>
</li>
<li><strong>hashCode()和hash值</strong><ul>
<li>Java中hashCode()方法是用来生成hashCode值,hashCode值是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。</li>
<li>把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是哈希值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。</li>
</ul>
</li>
<li><p><strong>为什么HashTable的大小控制为2的幂次数</strong></p>
<ul>
<li>降低碰撞的概率，使散列更均匀，根据bucket下标的计算公式，当哈希表的长度为2的次幂时，等同于使用表长度对hash值取模，散列更均匀。</li>
<li>表的长度为2的次幂，那么(length-1)的二进制最后一位一定是1，在对hash值做“与”运算时，最后一位就可能是1也可能是0，换句话说取模的结果既有奇数又有偶数。</li>
<li>此时<code>h &amp; (length-1)</code>就是<code>h % length</code></li>
</ul>
</li>
<li><p><strong>get()方法</strong></p>
<ul>
<li>通过key的hash值计算bucket的下标，然后遍历对应bucket上的链表，得到结果。</li>
</ul>
</li>
<li><p><strong>遍历Map的方式</strong></p>
<ul>
<li>Iterator迭代器</li>
<li>for(Map.Entry<string, integer> entry : testMap.entrySet())</string,></li>
<li>foreach(JDK1.8才有，不推荐，因为底层就是方式2)</li>
<li>获取keySet()的迭代器遍历<br>以上的底层都是迭代器</li>
</ul>
</li>
<li><p><strong>Iterator的实现</strong></p>
<ul>
<li>HashMap中增加了一个内部类HashIterator，循环哈希table，直到找到不为空的bucket为止。</li>
</ul>
</li>
<li><p><strong>fail-fast策略</strong></p>
<ul>
<li>在系统设计中，当遇到可能会诱导失败的条件时立即上报错误。</li>
<li>modCount域变量用于实现hashMap中的fail-fast。</li>
</ul>
</li>
</ol>
<h1 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h1><p>相比与JDK7，JDK8中的HashMap会将较长的链表(大于8)转为红黑树。</p>
<ol>
<li><p><strong>put()</strong></p>
<ul>
<li>在JDK7中，新增节点使用的是头插法，但在JDK8中，在链表使用尾插法，防止死链。</li>
<li>若hashTable为null或长度为0，则扩容。</li>
<li>根据index找到bucket，若bucket上没有节点，那么直接新增一个节点，赋给bucket。</li>
<li>若当前bucket上有链表，且头节点匹配，则直接替换。</li>
<li>若当前bucket上为树结构则转为红黑树的插入操作。</li>
<li>若以上都不成立，则对链表进行遍历：有则替换，无则末尾添加。</li>
<li>如果链表长度大于TREEIFY_THRESHOLD，则执行红黑树转换操作。</li>
</ul>
</li>
<li><p><strong>扩容</strong></p>
<ul>
<li>如果hashTable为null或长度为0，如果Map中存储的k-v对数量超过了threshold，则触发扩容</li>
<li>不同于JDK7，JDK8在做数据迁移的时候保持了顺序(preserve order)</li>
<li>新的索引值要么和原来的索引值一样，要么是原索引值的两倍，因为<code>h &amp; (length-1)</code>中<code>length-1</code>的低位全是1。例如原先的hashCode为:1010 … 11101(共32位)，将长度从16扩容到32，length-1从1111变为11111，然后根据公式做按位与，得出的结果后四位是一样的，第一位取决于hashCode对应位置上的值。</li>
</ul>
</li>
<li><p><strong>get()</strong></p>
<ul>
<li>根据key计算hash值，进一步计算得到hashTable的目标index，若此bucket上为红黑树，则在红黑树上查找，否则遍历链表。</li>
</ul>
</li>
</ol>
<h1 id="HashMap、HashTable"><a href="#HashMap、HashTable" class="headerlink" title="HashMap、HashTable"></a>HashMap、HashTable</h1><ol>
<li><p><strong>HashMap vs HashTable</strong></p>
<ul>
<li>HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.</li>
<li>HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.</li>
<li>HashMap is generally preferred over HashTable if thread synchronization is not needed</li>
</ul>
</li>
<li><p><strong>Why HashTable doesn’t allow null and HashMap does?</strong><br>To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.</p>
</li>
<li><p><strong>Why HashMap is not thread-safe?</strong></p>
<ul>
<li><p>Ideologically<br>A hash map is based on an array, where each item represents a bucket. As more keys are added, the buckets grow and at a certain threshold the array is recreated with a bigger size, its buckets rearranged so that they are spread more evenly (performance considerations).</p>
</li>
<li><p>Technically<br>It means that sometimes HashMap#put() will internally call HashMap#resize() to make the underlying array bigger.</p>
</li>
<li><p>HashMap#resize() assigns the table field a new empty array with a bigger capacity and populates it with the old items. While this population happens, the underlying array doesn’t contain all of the old items and calling HashMap#get() with an existing key may return null.</p>
</li>
</ul>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><strong>HashCode怎么算的?</strong><ul>
<li>memory reference of object in integer form</li>
</ul>
</li>
<li><strong>equals()</strong><ul>
<li>compare the key whether the are equal or not</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Q-What-is-difference-between-HashMap-and-Hashtable"><a href="#Q-What-is-difference-between-HashMap-and-Hashtable" class="headerlink" title="Q. What is difference between HashMap and Hashtable?"></a>Q. What is difference between HashMap and Hashtable?</h4><p>HashMap and Hashtable both are used to store data in key and value form. Both are using hashing technique to store unique keys.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Sl.No</th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>
<tbody>
<tr>
<td>01.</td>
<td>HashMap is <strong>non synchronized</strong>. It is not-thread safe and can’t be shared between many threads without proper synchronization code.</td>
<td>Hashtable is <strong>synchronized</strong>. It is thread-safe and can be shared with many threads.</td>
</tr>
<tr>
<td>02.</td>
<td>HashMap allows one null key and multiple null values.</td>
<td>Hashtable doesn’t allow any null key or value.</td>
</tr>
<tr>
<td>03.</td>
<td>HashMap is a new class introduced in JDK 1.2.</td>
<td>Hashtable is a legacy class.</td>
</tr>
<tr>
<td>04.</td>
<td>HashMap is fast.</td>
<td>Hashtable is slow.</td>
</tr>
<tr>
<td>05.</td>
<td>We can make the HashMap as synchronized by calling this code Map m = Collections.synchronizedMap(hashMap);</td>
<td>Hashtable is internally synchronized and can’t be unsynchronized.</td>
</tr>
<tr>
<td>06.</td>
<td>HashMap is traversed by Iterator.</td>
<td>Hashtable is traversed by Enumerator and Iterator.</td>
</tr>
<tr>
<td>07.</td>
<td>Iterator in HashMap is fail-fast.</td>
<td>Enumerator in Hashtable is not fail-fast.</td>
</tr>
<tr>
<td>08.</td>
<td>HashMap inherits AbstractMap class.</td>
<td>Hashtable inherits Dictionary class.</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2019/07/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><ol>
<li>Windows10 </li>
<li>Nodejs v10.16.0    </li>
<li>Hexo</li>
<li>Git v2.22.0</li>
</ol>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><p>建议<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网安装</a>，此处选择的是LTS版本（10.16.0），安装成功后在命令行输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -version  # 查看Nodejs版本号</span><br><span class="line">npm -version  # npm是随同Nodejs一起安装的包管理工具</span><br></pre></td></tr></table></figure></p>
<p>确认两项都成功安装即可。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>建议<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网安装</a>，当前安装版本为(v2.22.0)，安装成功后在命令行输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p>
<p>获取git版本并确认安装成功。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>使用命令行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<p>安装Hexo，通过<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p>
<p>确认安装并且可以得知Hexo是基于Nodejs的。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>   安装Nodejs和Git后要将它们添加进系统环境变量中，如图所示：</p>
<p>   <img src="//xiaokeliu666.github.io/2019/07/30/Hexo博客搭建/环境变量.png" alt></p>
<h1 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h1><h2 id="创建本地目录"><a href="#创建本地目录" class="headerlink" title="创建本地目录"></a>创建本地目录</h2><ol>
<li>新建一个文件夹，假设取名为Blog</li>
<li>通过GitBash进入该文件夹，使用命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init  # 初始化一个博客</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该指令会自动Clone所需文件，结果如图<br><img src="//xiaokeliu666.github.io/2019/07/30/Hexo博客搭建/初始化.png" alt></p>
<h2 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h2><p>使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s  # 启动服务</span><br></pre></td></tr></table></figure></p>
<p>博客会在localhost:4000被启动</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new (文章名)</span><br></pre></td></tr></table></figure></p>
<p>在 /source/_posts 生成文章，文章可以直接在本地用Visual Studio Code等软件以Markdown的语法编辑。</p>
<h2 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h2><p>使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  # 清除缓存文件</span><br><span class="line">hexo g  # 生成静态文件</span><br><span class="line">hexo s  # 启动服务器</span><br></pre></td></tr></table></figure></p>
<p>即可在localhost:4000中查看更新的文章</p>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>   新建一个Repository，必须以“用户名.github.io”的格式命名</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>   使用命令<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></p>
<p>   安装插件使博客可以部署到Github</p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>   编辑Blog目录下的文件_config.yml(可以使用Vim, notepad++等)<br>   <img src="//xiaokeliu666.github.io/2019/07/30/Hexo博客搭建/配置文件.png" alt></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d  # 部署</span><br></pre></td></tr></table></figure></p>
<p>就会自动部署到github，可能会要求输入github的账号和密码，也可以通过SSH完成Git与Github的绑定。<br>部署成功后本地文件会上传到Github的仓库里，直接通过仓库名作为地址就可以访问，到此已经部署成功。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;这次搭建实验总体顺利，文中有部分内容没有具体讲到，例如Git与Github的绑定，读者都可以在网上找到相应的教程，感谢B站UP主<a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=13144773842957588840" target="_blank" rel="noopener">CodeSheep</a>的讲解视频，更多细节可以参考上述视频。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo踩坑：本地图片加载</title>
    <url>/2019/07/30/Hexo%E8%B8%A9%E5%9D%91%EF%BC%9A%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><ol>
<li>Windows10</li>
<li>Hexo</li>
<li>Github</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>&emsp;&emsp;为了实现上传图片的功能，将Hexo主页的配置文件(_config.yml)中的post_asset_folder值修改为true后，在Hexo目录下执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></p>
<p>安装了一个上传本地图片的插件，该插件会在创建新的文章时同时创建一个同名的文件夹用来存放图片</p>
<p>&emsp;&emsp;文档中采取的加载图片的代码为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](文章名/图片名.png)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我是用上述方法向文章中添加图片时出现本地无法加载的情况，在localhost:4000或是我部署到Github上的博客中都只能显示出一个小方框，无法读取图片。</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>&emsp;&emsp;因为在网页上还能显示一个小方框，只是不能加载图片，所以可以得出大致的问题出在路径上。<br>&emsp;&emsp;通过观察GitBash在生成静态文件时返回的信息可得知图片路径的解析情况如图<br><img src="//xiaokeliu666.github.io/2019/07/30/Hexo踩坑：本地图片加载/无效路径.png" alt><br>其中 zhuomian.png 为目标图片，Hexo博客搭建为存放文件夹，其余部分为解析后加上去的，这个路径理所当然是加载不出图片的。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&emsp;&emsp;考虑到路径的解析可能会受配置文件控制，于是在配置文件中找到了相关的信息<br><img src="//xiaokeliu666.github.io/2019/07/30/Hexo踩坑：本地图片加载/错误配置路径.png" alt><br>以上为错误配置路径，于是我尝试把url修改成我自己的网址<br><img src="//xiaokeliu666.github.io/2019/07/30/Hexo踩坑：本地图片加载/正确配置路径.png" alt><br>之后再次生成静态文件后更新的链接看上去就正常了<br><img src="//xiaokeliu666.github.io/2019/07/30/Hexo踩坑：本地图片加载/有效路径.png" alt><br>再次部署之后，博客文章图片就加载正常了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;这个问题的解决方案并不完美，因为如果在部署之前先启动本地服务在localhost:4000上预览文章仍然无法加载图片，原因应该是部署过程中图片被上传到了github，新的图片路径指向的是github中图片的路径，但是经过测试发现在断网的情况下也能加载已经部署过的图片，所以这个解决方案暂时没有明显问题。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo配置优化</title>
    <url>/2019/07/31/Hexo%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Hexo的配置文件中有很多可以自定义修改的值，以及Github上有很多Hexo的主题可供下载，本文记录一下当前博客的修改过程，因为崇尚简洁而且不懂前端，所以没有太多花哨的优化。</p>
<h1 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h1><p>该博客使用的是<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT主题</a>，在GitBash中进入博客文件夹后使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>即可将主题下载到themes文件夹中，在这里也能找到主题所对应的配置文件。</p>
<h1 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h1><p>Vim中打开Hexo的配置文件(_config.yml)，对以下项目进行了修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Feb 1997  </span><br><span class="line">subtitle: Overtime and overdue</span><br><span class="line">author: Feb 1997  </span><br><span class="line">language: zh-CN  # 将主题的语言设定为中文</span><br><span class="line">theme: next  # 将主题设置为next</span><br></pre></td></tr></table></figure></p>
<h1 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h1><p>Vim中打开NexT的配置文件(_config.yml)，对一下项目进行了修改:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags: /tags/ || tags  # 菜单显示标签</span><br><span class="line">categories: /categories/ || th  # 菜单显示分类</span><br><span class="line">scheme: Pisces  # 选择主题的风格</span><br><span class="line">avatar:</span><br><span class="line">      url: /images/avatar.jpg  # 头像图片在 /source/images 里面</span><br><span class="line">      rounded: true  # 把头像设置成圆形展示</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;原模板已经很简洁了，因此在原主题的基础上没有太多的变动。更多油画不仅局限于配置文件的改动，很多前端的代码也可以改动以达到各种效果，网上已经有了很多分享，这里就不一一尝试了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator迭代器</title>
    <url>/2020/05/20/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">// strings.add(&quot;...&quot;)</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br></pre></td></tr></table></figure></p>
<h1 id="分析异常"><a href="#分析异常" class="headerlink" title="分析异常"></a>分析异常</h1><p>&emsp;&emsp;问题出现在两个方法上:checkForComodification()和next()，后者是我在程序中调用的方法，前者之前没见过，我决定从头开始查找源码问题。</p>
<h2 id="创造迭代器"><a href="#创造迭代器" class="headerlink" title="创造迭代器"></a>创造迭代器</h2><p>&emsp;&emsp;例子中通过<code>strings.iterator()</code>返回一个迭代器，其中<code>strings</code>是一个ArrayList的实例。<br>&emsp;&emsp;查找ArrayList的源码，并没有iterator()方法，于是找到其父类AbstractList中:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说创造一个迭代器返回的是一个Itr类型对象的引用。<br>&emsp;&emsp;来看Itr:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    int cursor = 0;</span><br><span class="line">  </span><br><span class="line">    int lastRet = -1;</span><br><span class="line"></span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = cursor;</span><br><span class="line">            E next = get(i);</span><br><span class="line">            lastRet = i;</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return next;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            AbstractList.this.remove(lastRet);</span><br><span class="line">            if (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的成员变量：<br>cursor: 游标，表示下一个要访问的元素的索引，在next方法中会自增<br>lastRet: 上一个元素的索引<br>expectedModCount: 表示对ArrayList修改次数的期望值，初始值为modCount<br>modCount: AbstractList类中的一个成员变量，表示对List的修改次数(structurally modified)，每次add()和remove()就会加1</p>
<h1 id="解决错误"><a href="#解决错误" class="headerlink" title="解决错误"></a>解决错误</h1><p>在Itr的源码中可以看到，迭代器中的操作都要先执行checkForComodificatioin()方法来确定<code>modCount!=expectedModCount</code>,这是保护ArrayList的机制，防止返回错误结果。</p>
<h2 id="错误的原因可能在于创建迭代器之后添加元素也算是产生了结构性的变化。"><a href="#错误的原因可能在于创建迭代器之后添加元素也算是产生了结构性的变化。" class="headerlink" title="错误的原因可能在于创建迭代器之后添加元素也算是产生了结构性的变化。"></a>错误的原因可能在于创建迭代器之后添加元素也算是产生了结构性的变化。</h2><h4 id="Q-What-is-the-difference-between-fail-fast-and-fail-safe-iterator"><a href="#Q-What-is-the-difference-between-fail-fast-and-fail-safe-iterator" class="headerlink" title="Q. What is the difference between fail-fast and fail-safe iterator?"></a>Q. What is the difference between fail-fast and fail-safe iterator?</h4><p><strong>fail-fast Iterator</strong>  </p>
<p><code>Iterators</code> in java are used to iterate over the Collection objects.Fail-Fast iterators immediately throw <code>ConcurrentModificationException</code> if there is <strong>structural modification</strong> of the collection. Structural modification means adding, removing or updating any element from collection while a thread is iterating over that collection. Iterator on ArrayList, HashMap classes are some examples of fail-fast Iterator.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFastIteratorExample</span> </span></span><br><span class="line"><span class="class"></span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Creating an ArrayList of integers</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Adding elements to list</span></span><br><span class="line">        list.add(<span class="number">1452</span>);</span><br><span class="line">        list.add(<span class="number">6854</span>);</span><br><span class="line">        list.add(<span class="number">8741</span>);</span><br><span class="line">                 </span><br><span class="line">        <span class="comment">//Getting an Iterator from list</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Integer integer = (Integer) it.next();</span><br><span class="line">            list.add(<span class="number">8457</span>);      <span class="comment">//This will throw ConcurrentModificationException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)</span><br><span class="line">    at java.util.ArrayList$Itr.next(Unknown Source)</span><br><span class="line">    at pack1.MainClass.main(MainClass.java:32)</span><br></pre></td></tr></table></figure></p>
<p><strong>fail-safe Iterator</strong>  </p>
<p>Fail-Safe iterators don’t throw any exceptions if a collection is structurally modified while iterating over it. This is because, they operate on the clone of the collection, not on the original collection and that’s why they are called fail-safe iterators. Iterator on CopyOnWriteArrayList, ConcurrentHashMap classes are examples of fail-safe Iterator.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailSafeIteratorExample</span> </span></span><br><span class="line"><span class="class"></span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Creating a ConcurrentHashMap</span></span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Adding elements to map</span></span><br><span class="line">        map.put(<span class="string">"ONE"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"TWO"</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"THREE"</span>, <span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Getting an Iterator from map</span></span><br><span class="line">        Iterator&lt;String&gt; it = map.keySet().iterator();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String key = (String) it.next();</span><br><span class="line">            System.out.println(key+<span class="string">" : "</span>+map.get(key));</span><br><span class="line">            map.put(<span class="string">"FOUR"</span>, <span class="number">4</span>); <span class="comment">//This will not be reflected in the Iterator</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TWO : 2</span><br><span class="line">FOUR : 4</span><br><span class="line">ONE : 1</span><br><span class="line">THREE : 3</span><br></pre></td></tr></table></figure></p>
<div align="right">
    <b><a href="#">↥ back to top</a></b>
</div>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC面试题</title>
    <url>/2020/05/26/JDBC%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Q-What-is-DAO-factory-design-pattern-in-Java"><a href="#Q-What-is-DAO-factory-design-pattern-in-Java" class="headerlink" title="Q. What is DAO factory design pattern in Java?"></a>Q. What is DAO factory design pattern in Java?</h4><p>Data Access Object Pattern or DAO pattern is used to separate low level data accessing API or operations from high level business services.</p>
<p>DAO pattern is based on abstraction and encapsulation design principles and shields rest of application from any change in the persistence layer e.g. change of database from Oracle to MySQL, change of persistence technology e.g. from File System to Database.</p>
<h4 id="Q-What-are-the-differences-between-ResultSet-and-RowSet"><a href="#Q-What-are-the-differences-between-ResultSet-and-RowSet" class="headerlink" title="Q. What are the differences between ResultSet and RowSet?"></a>Q. What are the differences between ResultSet and RowSet?</h4><p>A <strong>ResultSet</strong> maintains a connection to a database and because of that it can’t be serialized and also we cant pass the Resultset object from one class to other class across the network.</p>
<p><strong>RowSet</strong> is a disconnected, serializable version of a JDBC ResultSet and also the RowSet extends the ResultSet interface so it has all the methods of ResultSet. The RowSet can be serialized because it doesn’t have a connection to any database and also it can be sent from one class to another across the network.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ResultSet</th>
<th>RowSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>A ResultSet always maintains connection with the database.</td>
<td>A RowSet can be connected, disconnected from the database.</td>
</tr>
<tr>
<td>It cannot be serialized.</td>
<td>A RowSet object can be serialized.</td>
</tr>
<tr>
<td>ResultSet object cannot be passed other over network.</td>
<td>You can pass a RowSet object over the network.</td>
</tr>
<tr>
<td>ResultSet object is not a JavaBean object You can create/get a result set using the executeQuery() method.</td>
<td>ResultSet Object is a JavaBean object. You can get a RowSet using the RowSetProvider.newFactory().createJdb cRowSet() method.</td>
</tr>
<tr>
<td>By default, ResultSet object is not scrollable or, updatable.</td>
<td>By default, RowSet object is scrollable and updatable.</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Q-How-can-we-execute-stored-procedures-using-CallableStatement"><a href="#Q-How-can-we-execute-stored-procedures-using-CallableStatement" class="headerlink" title="Q. How can we execute stored procedures using CallableStatement?"></a>Q. How can we execute stored procedures using CallableStatement?</h4><p><strong>CallableStatement</strong> interface in java is used to call stored procedure from java program. <strong>Stored Procedures</strong> are group of statements that we compile in the database for some task. Stored procedures are beneficial when we are dealing with multiple tables with complex scenario and rather than sending multiple queries to the database, we can send required data to the stored procedure and have the logic executed in the database server itself.</p>
<p>A CallableStatement object provides a way to call stored procedures using JDBC. Connection.prepareCall() method provides you CallableStatement object.</p>
<h4 id="Q-What-are-the-differences-between-Statement-and-PreparedStatement-interface"><a href="#Q-What-are-the-differences-between-Statement-and-PreparedStatement-interface" class="headerlink" title="Q. What are the differences between Statement and PreparedStatement interface?"></a>Q. What are the differences between Statement and PreparedStatement interface?</h4><p>JDBC API provides 3 different interfaces to execute the different types of SQL queries. They are,</p>
<ul>
<li><strong>Statement</strong>  –  Used to execute normal SQL queries.</li>
<li><strong>PreparedStatement</strong>  –  Used to execute dynamic or parameterized SQL queries.</li>
<li><strong>CallableStatement</strong>  –  Used to execute the stored procedures.</li>
</ul>
<p><strong>1. Statement</strong>  </p>
<p>Statement interface is used to execute normal SQL queries. We can’t pass the parameters to SQL query at run time using this interface. This interface is preferred over other two interfaces if we are executing a particular SQL query only once. The performance of this interface is also very less compared to other two interfaces. In most of time, Statement interface is used for DDL statements like <strong>CREATE, ALTER, DROP</strong> etc.</p>
<p><strong>2. PreparedStatement</strong>  </p>
<p>PreparedStatement is used to execute dynamic or parameterized SQL queries. PreparedStatement extends Statement interface. We can pass the parameters to SQL query at run time using this interface. It is recommended to use PreparedStatement if we are executing a particular SQL query multiple times. It gives better performance than Statement interface. Because, PreparedStatement are precompiled and the query plan is created only once irrespective of how many times we are executing that query. </p>
<p><strong>3. CallableStatement</strong>  </p>
<p>CallableStatement is used to execute the stored procedures. CallableStatement extends PreparedStatement. Usng CallableStatement, we can pass 3 types of parameters to stored procedures. They are : <strong>IN</strong> – used to pass the values to stored procedure, <strong>OUT</strong> – used to hold the result returned by the stored procedure and <strong>IN OUT</strong> – acts as both IN and OUT parameter. Before calling the stored procedure, we must register OUT parameters using <strong>registerOutParameter()</strong> method of CallableStatement. The performance of this interface is higher than the other two interfaces. Because, it calls the stored procedures which are already compiled and stored in the database server.</p>
<h4 id="Q-What-are-the-different-types-of-locking-in-JDBC"><a href="#Q-What-are-the-different-types-of-locking-in-JDBC" class="headerlink" title="Q. What are the different types of locking in JDBC?"></a>Q. What are the different types of locking in JDBC?</h4><p>The types of locks in JDBC:</p>
<p><strong>1. Row and Key Locks</strong>: Useful when updating the rows (update, insert or delete operations), as they increase concurrency.</p>
<p><strong>2. Page Locks</strong>: Locks the page when the transaction updates or inserts or deletes rows or keys. The database server locks the entire page that contains the row. The lock is made only once by database server, even more rows are updated. This lock is suggested in the situation where large number of rows is to be changed at once.</p>
<p><strong>3. Table Locks</strong>: Utilizing table locks is efficient when a query accesses most of the tables of a table. These are of two types:<br><strong>a) Shared lock</strong>: One shared lock is placed by the database server, which prevents other to perform any update operations.</p>
<p><strong>b) Exclusive lock</strong>: One exclusive lock is placed by the database server, irrespective of the number of the rows that are updated.</p>
<p><strong>4. Database Lock</strong>: In order to prevent the read or update access from other transactions when the database is open, the database lock is used.</p>
]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: Abstraction and Encapsulation</title>
    <url>/2020/05/26/Java-Abstraction-and-Encapsulation/</url>
    <content><![CDATA[<h4 id="Q-What-is-the-difference-between-abstraction-and-encapsulation"><a href="#Q-What-is-the-difference-between-abstraction-and-encapsulation" class="headerlink" title="Q. What is the difference between abstraction and encapsulation?"></a>Q. <strong><em>What is the difference between abstraction and encapsulation?</em></strong></h4><ul>
<li>Abstraction solves the problem at design level while Encapsulation solves it implementation level. </li>
<li>In Java, Abstraction is supported using <code>interface</code> and <code>abstract class</code> while Encapsulation is supported using access modifiers e.g. public, private and protected.</li>
<li>Abstraction is about hiding unwanted details while giving out most essential details, while Encapsulation means hiding the code and data into a single unit e.g. class or method to protect inner working of an object from outside world. </li>
</ul>
<table class="alt">
<tbody><tr><th>Abstraction</th><th>Encapsulation</th></tr>
<tr><td>Abstraction is a process of hiding the implementation details and showing only functionality to the user.</td>
<td> Encapsulation is a process of wrapping code and data together into a single unit</td></tr>
<tr><td>Abstraction lets you focus on what the object does instead of how it does it.</td>
<td>Encapsulation provides you the control over the data and keeping it safe from outside misuse.</td></tr>
<tr><td>Abstraction solves the problem in the Design Level.</td>
<td>Encapsulation solves the problem in the Implementation Level.</td></tr>
<tr><td>Abstraction is implemented by using Interfaces and Abstract Classes.</td>
<td>Encapsulation is implemented by using Access Modifiers (private, default, protected, public)</td></tr>
<tr><td>Abstraction means hiding implementation complexities by using interfaces and abstract class.</td>
<td>Encapsulation means hiding data by using setters and getters.</td></tr>
</tbody></table>

<h4 id="Q-Can-there-be-an-abstract-method-without-an-abstract-class"><a href="#Q-Can-there-be-an-abstract-method-without-an-abstract-class" class="headerlink" title="Q. Can there be an abstract method without an abstract class?"></a>Q. <strong><em>Can there be an abstract method without an abstract class?</em></strong></h4><p>Yes. because methods in an interface are also abstract. so the interface can be use to declare abstract method.</p>
<h4 id="Q-Can-we-use-private-or-protected-member-variables-in-an-interface"><a href="#Q-Can-we-use-private-or-protected-member-variables-in-an-interface" class="headerlink" title="Q. Can we use private or protected member variables in an interface?"></a>Q. <strong><em>Can we use private or protected member variables in an interface?</em></strong></h4><p>The java compiler adds public and abstract keywords before the interface method and <strong>public, static and final keyword</strong> before data members automatically<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> string name1;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="keyword">protected</span> pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>as you have declare variable in test interface with private and protected it will give error. if you do not specify the modifier the compiler will add public static final automatically.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> string name1;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  String email;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>interfaces cannot be instantiated that is why the variable are <strong>static</strong></li>
<li>interface are used to achieve the 100% abstraction there for the variable are <strong>final</strong></li>
<li>An interface provide a way for the client to interact with the object. If variables were not public, the clients would not have access to them. that is why variable are <strong>public</strong></li>
</ul>
<h4 id="Q-When-can-an-object-reference-be-cast-to-a-Java-interface-reference"><a href="#Q-When-can-an-object-reference-be-cast-to-a-Java-interface-reference" class="headerlink" title="Q. When can an object reference be cast to a Java interface reference?"></a>Q. <strong><em>When can an object reference be cast to a Java interface reference?</em></strong></h4><p>An interface reference can point to any object of a class that implements this interface </p>
<pre><code class="lang-java">interface Foo {
  void display();
}

public class TestFoo implements Foo {

    void display() {
      System.out.println(&quot;Hello World&quot;);
    }

    public static void main(String[] args) {
      Foo foo = new TestFoo();
      foo.display();
    }
}
</code></pre>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：GET还是POST</title>
    <url>/2020/05/30/Java%EF%BC%9AGET%E8%BF%98%E6%98%AFPOST%EF%BC%9F/</url>
    <content><![CDATA[<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: Heap and Stack</title>
    <url>/2020/05/26/Java-Heap-and-Stack/</url>
    <content><![CDATA[<h4 id="Q-What-is-difference-between-Heap-and-Stack-Memory-in-java"><a href="#Q-What-is-difference-between-Heap-and-Stack-Memory-in-java" class="headerlink" title="Q. What is difference between Heap and Stack Memory in java?"></a>Q. <strong><em>What is difference between Heap and Stack Memory in java?</em></strong></h4><p><strong>Java Heap Space</strong>  </p>
<p>Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.</p>
<p>Garbage Collection runs on the heap memory to free the memory used by objects that doesn’t have any reference. Any object created in the heap space has global access and can be referenced from anywhere of the application.</p>
<p><strong>Java Stack Memory</strong>  </p>
<p>Stack in java is a section of memory which contains methods, local variables and reference variables. Local variables are created in the stack.</p>
<p>Stack memory is always referenced in LIFO (Last-In-First-Out) order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.</p>
<p>As soon as method ends, the block becomes unused and become available for next method. Stack memory size is very less compared to Heap memory.</p>
<p><strong>Difference</strong>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Stack Memory</th>
<th>Heap Space</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application</td>
<td>Stack is used in parts, one at a time during execution of a thread</td>
<td>The entire application uses Heap space during runtime</td>
</tr>
<tr>
<td>Size</td>
<td>Stack has size limits depending upon OS and is usually smaller then Heap</td>
<td>There is no size limit on Heap</td>
</tr>
<tr>
<td>Storage</td>
<td>Stores only primitive variables and references to objects that are created in Heap Space</td>
<td>All the newly created objects are stored here</td>
</tr>
<tr>
<td>Order</td>
<td>It is accessed using Last-in First-out (LIFO) memory allocation system</td>
<td>This memory is accessed via complex memory management techniques that include Young Generation, Old or Tenured Generation, and Permanent Generation.</td>
</tr>
<tr>
<td>Life</td>
<td>Stack memory only exists as long as the current method is running</td>
<td>Heap space exists as long as the application runs</td>
</tr>
<tr>
<td>Efficiency</td>
<td>Comparatively much faster to allocate when compared to heap</td>
<td>Slower to allocate when compared to stack</td>
</tr>
<tr>
<td>Allocation/Deallocation</td>
<td>This Memory is automatically allocated and deallocated when a method is called and returned respectively</td>
<td>Heap space is allocated when new objects are created and deallocated by Gargabe Collector when they are no longer referenced</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：Lambda Comparator</title>
    <url>/2020/04/20/Java%EF%BC%9ALambda-Comparator/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<a href="https://mkyong.com/java8/java-8-lambda-comparator-example/" target="_blank" rel="noopener">https://mkyong.com/java8/java-8-lambda-comparator-example/</a></p>
</blockquote>
<p>在这个例子中，我将会展示如何使用Java 8 Lambda表达式去写一个Comparator来对List进行排序。</p>
<ol>
<li><p>传统Comparator例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Developer&gt; byName = new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getName().compareTo(o2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>等价的Lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Developer&gt; byName = </span><br><span class="line">(Developer o1, Developer o2) -&gt; o1.getName().compareTo(o2.getName());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="不用Lambda排序"><a href="#不用Lambda排序" class="headerlink" title="不用Lambda排序"></a>不用Lambda排序</h1><p>举个通过age属性对Developer对象进行排序的例子。通常，你使用Collections.sort然后传入匿名Comparator类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSorting &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Developer&gt; listDevs = getDevelopers();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Befor sort&quot;);</span><br><span class="line">        for(Developer developer:listDevs) &#123;</span><br><span class="line">            System.out.println(developer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //sort by age</span><br><span class="line">        Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Developer o1,Developer o2) &#123;</span><br><span class="line">                return o1,getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;After Sort&quot;);</span><br><span class="line">        for(Developer developer:ListDevs) &#123;</span><br><span class="line">            System.out.println(developer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Developer&gt; getDevelopers() &#123;</span><br><span class="line">        List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;();</span><br><span class="line"></span><br><span class="line">        result.add(new Developer(&quot;mkyong&quot;, new BigDecimal(&quot;70000&quot;),33));</span><br><span class="line">        result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;),20));</span><br><span class="line">        result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;),10));</span><br><span class="line">        result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;),55));</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before Sort</span><br><span class="line">Developer [name=mkyong, salary=7000, age=33]</span><br><span class="line">Developer [name=alvin, salary=8000, age=20]</span><br><span class="line">Developer [name=jason, salary=10000, age=10]</span><br><span class="line">Developer [name=iris, salary=17000, age=55]</span><br><span class="line"></span><br><span class="line">After Sort</span><br><span class="line">Developer [name=jason, salary=10000, age=10]</span><br><span class="line">Developer [name=alvin, salary=8000, age=20]</span><br><span class="line">Developer [name=mkyong, salary=7000, age=33]</span><br><span class="line">Developer [name=iris, salary=17000, age=55]</span><br></pre></td></tr></table></figure></p>
<p>如果排序要求变了，你只需要传入另一个匿名Comparator类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sort by age</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// sort by name</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getName().compareTo(o2.getNmae());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//sort by salary</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getSalary().compareTo(o2.getSlary());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这方法有效，但是你不觉得这样有点奇怪吗，因为你只想改变一行代码却创建了一个新的类。</p>
<h1 id="用Lambda排序"><a href="#用Lambda排序" class="headerlink" title="用Lambda排序"></a>用Lambda排序</h1><p>在Java 8中，List接口直接支持sort方法，不需要再用Collections.sort<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Java 8 之后的List.sort()</span><br><span class="line">listDevs.sort(new Comparator&lt;Deceloper&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o2.getAge()-o1.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Lambda表达式例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSorting &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Developer&gt; listDevs = getDevelopers();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Before Sort&quot;);</span><br><span class="line">        for(Developer developer : listDevs) &#123;</span><br><span class="line">            System.out.println(developer);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;After Sort&quot;);</span><br><span class="line">        // lambda</span><br><span class="line">        listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge());</span><br><span class="line">        listDevs.forEach((developer)-&gt;System.out.println(developer));</span><br><span class="line">    &#125;</span><br><span class="line">    private static List&lt;Developer&gt; getDevelopers() &#123;</span><br><span class="line">        List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;();</span><br><span class="line"></span><br><span class="line">        result.add(new Developer(&quot;mkyong&quot;, new BigDecimal(&quot;70000&quot;),33));</span><br><span class="line">        result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;),20));</span><br><span class="line">        result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;),10));</span><br><span class="line">        result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;),55));</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出和前面的例子一样。</p>
<h1 id="更多lambda的例子"><a href="#更多lambda的例子" class="headerlink" title="更多lambda的例子"></a>更多lambda的例子</h1><h2 id="Sort-by-age"><a href="#Sort-by-age" class="headerlink" title="Sort by age"></a>Sort by age</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// sort by age</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//lambda</span><br><span class="line">listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge());</span><br><span class="line">//同样有效的lambda，参数类型不是必须的</span><br><span class="line">listDevs.sort((o1, o2)-&gt;o1.getAge()-o2.getAge());</span><br></pre></td></tr></table></figure>
<h2 id="Sort-by-Name"><a href="#Sort-by-Name" class="headerlink" title="Sort by Name"></a>Sort by Name</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// sort by name</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getName().compareTo(o2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//lambda</span><br><span class="line">listDevs.sort((Developer o1, Developer o2)-&gt;o1.getName().compareTo(o2.getName()));</span><br><span class="line">//同样有效的lambda，参数类型不是必须的</span><br><span class="line">listDevs.sort((o1, o2)-&gt;o1.getName().compareTo(o2.getName()));</span><br></pre></td></tr></table></figure>
<h2 id="Sort-by-salary"><a href="#Sort-by-salary" class="headerlink" title="Sort by salary"></a>Sort by salary</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sort by salary</span><br><span class="line">Collections.sort(listDevs, new Comparator&lt;Developer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Developer o1, Developer o2) &#123;</span><br><span class="line">        return o1.getSalary().compareTo(o2.getSalary());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//lambda</span><br><span class="line">listDevs.sort((Developer o1, Developer o2)-&gt;o1.getSalary().compareTo(o2.getSalary()));</span><br><span class="line">//同样有效的lambda，参数类型不是必须的</span><br><span class="line">listDevs.sort((o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary()));</span><br></pre></td></tr></table></figure>
<h1 id="反向排序"><a href="#反向排序" class="headerlink" title="反向排序"></a>反向排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Developer&gt; salaryComparator = (o1, o2)-&gt;o1.getSalary().compareTo(o2.getSalary());</span><br><span class="line">listDevs.sort(salaryComparator.reversed());</span><br></pre></td></tr></table></figure>
<p>个人理解就是把前面的正向排序的lambda表达式拆分城两部分，一部分是用lambda表达式把Comparator实现，另一部分则是把Comparator的对象作为参数传入sort方法，并且可以使用.reversed()</p>
<hr>
<h4 id="Q-What-is-Comparable-and-Comparator-Interface-in-java"><a href="#Q-What-is-Comparable-and-Comparator-Interface-in-java" class="headerlink" title="Q. What is Comparable and Comparator Interface in java?"></a>Q. What is Comparable and Comparator Interface in java?</h4><p>Comparable and Comparator both are interfaces and can be used to sort collection elements.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody>
<tr>
<td>1) Comparable provides a single sorting sequence. In other words, we can sort the collection on the basis of a single element such as id, name, and price.</td>
<td>The Comparator provides multiple sorting sequences. In other words, we can sort the collection on the basis of multiple elements such as id, name, and price etc.</td>
</tr>
<tr>
<td>2) Comparable affects the original class, i.e., the actual class is modified.</td>
<td>Comparator doesn’t affect the original class, i.e., the actual class is not modified.</td>
</tr>
<tr>
<td>3) Comparable provides compareTo() method to sort elements.</td>
<td>Comparator provides compare() method to sort elements.</td>
</tr>
<tr>
<td>4) Comparable is present in java.lang package.</td>
<td>A Comparator is present in the java.util package.</td>
</tr>
</tbody>
</table>
</div>
<p>5) We can sort the list elements of Comparable type by Collections.sort(List) method.|We can sort the list elements of Comparator type by Collections.sort(List, Comparator) method.|</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：Static关键字</title>
    <url>/2019/08/21/Java%EF%BC%9AStatic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="Static介绍与用法"><a href="#Static介绍与用法" class="headerlink" title="Static介绍与用法"></a>Static介绍与用法</h1><p>&emsp;&emsp;通常来说，当创建类时，就是在描述那个类的对象的外观与行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。<br>&emsp;&emsp;有两种情形用上述方法是无解的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能调用这个方法。<br>&emsp;&emsp;通过static关键字可以满足这两方面的需要。当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的对任何对象，也可以调用其static方法或访问其static域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非static域和方法必须知道他们一起运作的特定对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line">    static int i = 47;</span><br><span class="line">    int j = 47;</span><br><span class="line">    static void incrementi()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    void incrementj()&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StaticTest st1 = new StaticTest();</span><br><span class="line">        StaticTest st2 = new StaticTest();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;st1.i: &quot; + st1.i);</span><br><span class="line">        System.out.println(&quot;st2.i: &quot; + st2.i);</span><br><span class="line"></span><br><span class="line">        st1.incrementi();</span><br><span class="line">        System.out.println(&quot;st1.incrementi()后的st1.i: &quot; + st1.i);</span><br><span class="line">        System.out.println(&quot;st1.incrementi()后的st2.i: &quot; + st2.i);</span><br><span class="line"></span><br><span class="line">        st1.incrementj();</span><br><span class="line">        System.out.println(&quot;st1.incrementj()后的st1.j: &quot; + st1.j);</span><br><span class="line">        System.out.println(&quot;st1.incrementj()后的st2.j: &quot; + st2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Output:</span><br><span class="line">st1.i: 47</span><br><span class="line">st2.i: 47</span><br><span class="line">st1.incrementi()后的st1.i: 48</span><br><span class="line">st1.incrementi()后的st2.i: 48</span><br><span class="line">st1.incrementj()后的st1.j: 48</span><br><span class="line">st1.incrementj()后的st2.j: 47</span><br></pre></td></tr></table></figure></p>
<p>以上代码中i是静态变量，incrementi()是静态方法。创建两个对象并且只对其中一个执行incrementi()方法得出的输出中，两个对象的i属性都加了1。incrementj()不是静态方法，所以st1执行incrementj()后，st2的j值不变。</p>
<p>&emsp;&emsp;将字段或方法设定为static，即使创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象公像一个i，上例中的st1.i和st2.j指向同一存储空间。</p>
<p>引用static对象时可以通过类名直接引用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StaticTest.i++</span><br></pre></td></tr></table></figure></p>
<p>或者因为incrementi()是一个静态方法，也可以直接通过类调用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StaticTest.incrementi()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;尽管当static作用于某个字段时，肯定会改变数据创建的方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间），但是如果static作用于某个方法，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它，这一点对定义main()方法很重要，这个方法是运行一个应用时的一个入口点。</p>
<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>&emsp;&emsp;对于Static的理解我个人认为重点是认识到Static的字段，不管创建多少个对象，字段都是指向同一个存储空间，也就是说都是同时改变的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《JAVA编程思想第四版》</p>
</blockquote>
<hr>
<p>Q:为什么main函数中不能定义static变量？<br>A:只有类才存在静态的变量，方法只能对静态变量的操作，不能在方法内试图定义静态变量。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：Lambda表达式</title>
    <url>/2019/10/19/Java%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>今天在学习过程中写了这样一段代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Game &#123; boolean move(); &#125;</span><br><span class="line">interface GameFactory &#123; Game getGame(); &#125;</span><br><span class="line"></span><br><span class="line">class Checkers implements Game &#123;</span><br><span class="line">    private int moves = 0;</span><br><span class="line">    private static final int MOVES =3;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean move() &#123;</span><br><span class="line">        System.out.println(&quot;Checkers move &quot; + moves);</span><br><span class="line">        return ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static GameFactory factory = new GameFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Game getGame() &#123;</span><br><span class="line">            return new Checkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时编译器在<code>new GameFactory()</code>处提醒 Anonymous new GameFactory() can be replaced with lambda。点击后整个方法块被<code>public static GameFactory factory = () -&gt; new Checkers();</code>所替代，这就是lambda表达式。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式，也可称为闭包，它是推动Java 8 发布的最重要新特性。<br>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用Lambda表达式可以是代码变的更加简洁紧凑。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Lambda表达式的语法格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据语法回到之前的例子:<code>public static GameFactory factory = () -&gt; new Checkers();</code>表示的就是不需要参数，返回值为一个Checkers对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：is-a和has-a</title>
    <url>/2019/08/29/Java%EF%BC%9Ais-a%E5%92%8Chas-a/</url>
    <content><![CDATA[<p>之前讨论过Java的代码复用问题，其中提到了组合、继承和代理三中复用方法。在进一步了解这三种方法的使用场景时，首先需要鉴别类之间的关系。</p>
<h1 id="is-a"><a href="#is-a" class="headerlink" title="is-a"></a>is-a</h1><p>is-a：该关系依赖于继承。如果A是B，那么B就是A的基类。<br>比如土豆是蔬菜，公交车是载具，灯泡是电器等等。继承的一个性质就是继承是单向的，比如说公寓是建筑物，但是不是所有建筑物都是公寓。</p>
<h1 id="has-a"><a href="#has-a" class="headerlink" title="has-a"></a>has-a</h1><p>has-a：这种关系称为组合。如果A中有B，那么B就是A的组成部分。<br>一个类的实例有指向另一个类的索引或者同一个类的其他实例。比如汽车有引擎，狗有尾巴等等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：protected提供包访问权限</title>
    <url>/2019/08/25/Java%EF%BC%9Aprotected%E6%8F%90%E4%BE%9B%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;Java类中的属性在不指定访问权限，即private、protected或者public的情况下被称为“默认访问模式”，该模式下，只允许在同一个包中访问。<br>&emsp;&emsp;当需要继承的类来自另外一个包(packet)时，如果父类中的方法是私有的或者是默认访问模式（即未指定的），那么子类是不能继承的,<br>父类代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package 01;</span><br><span class="line"></span><br><span class="line">public class Cookie &#123;</span><br><span class="line">    public Cookie()&#123;</span><br><span class="line">        System.out.println(&quot;Cookie constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void bite()&#123;</span><br><span class="line">        System.out.println(&quot;bite&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子类代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package 02;</span><br><span class="line">import 01.Cookie;  // 导入父类所在的包</span><br><span class="line"></span><br><span class="line">public class ChocolateChip extends Cookie&#123;</span><br><span class="line">    public ChocolateChip()&#123;</span><br><span class="line">        System.out.println(&quot;ChocolateChip constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void chomp()&#123;</span><br><span class="line">        bite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChocolateChip x = new ChocolateChip();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error:(9, 9) java: 找不到符号</span><br><span class="line">符号:   方法 bite()</span><br><span class="line">位置: 类 com.demo.xliu294.ChocolateChip</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;假设我们现在希望子类可以继承来自另外一个包的父类中的方法，可以将父类中的该方法设置为public或者protected，但是如果把它指定为public的话，所有的人都有了访问权限，这样是不合适的。但是如果改成protected的话，子类中的bite()就可以访问了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包中的public成员。（当然，如果在同一个包内执行继承工作，就可以操纵所有的拥有包访问权限的成员。）有时，基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。protected也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《Java编程思想》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：valueOf()方法</title>
    <url>/2019/09/17/Java%EF%BC%9AvalueOf-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 这里应该输出两个true，实际输出的却是两个false</span><br><span class="line">        // 请查找、思考并修复numberEquals方法中的问题</span><br><span class="line">        System.out.println(numberEquals(&quot;1234&quot;, &quot;+1234&quot;));</span><br><span class="line">        System.out.println(numberEquals(&quot;1234&quot;, &quot;1234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断两个字符串是否包含相等的数字</span><br><span class="line">    // 例如a为&quot;+1234&quot;，b为&quot;1234&quot;，返回true</span><br><span class="line">    public static boolean numberEquals(String a, String b) &#123;</span><br><span class="line">        return Integer.valueOf(a) == Integer.valueOf(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>通过查看valueOf()方法的源码查看方法的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Integer的作者在写这个类时，为了避免重复创建对象，对Integer值做了缓存，如果输入的整型参数在[IntegerCache.low, IntegerCache.high]内，那么直接返回缓存好的对象，反之new一个新的对象Integer()。<br>那么缓存的内容是什么呢？看一下IntegerCache这个类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">        static final int low = -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        static final Integer cache[];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            // high value may be configured by property</span><br><span class="line">            int h = 127;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">            if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, 127);</span><br><span class="line">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = new Integer[(high - low) + 1];</span><br><span class="line">            int j = low;</span><br><span class="line">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">            // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">            assert IntegerCache.high &gt;= 127;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中首先检查虚拟机里有没有相应的配置，如果有，取该值，反之取默认的127。然后创建缓存数组，并给数组初始化值。这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，回去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存-128到127之间的值。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>把valueOf()方法替换成parseInt()方法即可，parseInt()返回的是基本类型int。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：为什么要get和set方法</title>
    <url>/2020/04/04/Java%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81get%E5%92%8Cset%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在JavaBean中，通常将属性设置为private，然后生成与属性对应的public setXXX(),public getXXX()。那么为什么要这么设计呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>同一个类</th>
<th style="text-align:center">同一个包</th>
<th style="text-align:right">同一个包下的子类</th>
<th style="text-align:right">不同包下的子类</th>
<th style="text-align:right">不同包的非子类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td style="text-align:center">+</td>
<td style="text-align:right">+</td>
<td style="text-align:right">+</td>
<td style="text-align:right">+</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">+</td>
<td style="text-align:right">+</td>
<td style="text-align:right">+</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>private</td>
<td style="text-align:center">+</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
</div>
<p>根据上表可以得知，将属性设置为private限制了外界对这个属性的直接访问操作，那么设置对应的get、set方法并设为public的意义就相当于给外界提供了访问的方法，而不是直接将属性暴露。</p>
<p>引用Stackoverflow的答案：</p>
<ul>
<li>Encapsulation of behavior associated with getting or setting the property this allows additional functionality (like validation) to be added more easily later.</li>
<li>Hiding the internal representation of the property while exposing a property using an alternative representation.</li>
<li>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</li>
<li>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</li>
<li>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</li>
<li>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</li>
<li>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</li>
<li>Allowing the getter/setter to be passed around as lambda expressions rather than values.</li>
<li>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</li>
</ul>
<p>自己目前所理解的：</p>
<ul>
<li>实现java域变量的封装性和安全性</li>
<li>可以对属性进行验证操作，比如age属性，在set中可以添加验证，如果输入的age小于0则抛出异常</li>
<li>可以在debug的时候用到</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java踩坑：初始化顺序</title>
    <url>/2019/08/25/Java%E8%B8%A9%E5%9D%91%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>求以下输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Window &#123;</span><br><span class="line">    Window(int marker)&#123;</span><br><span class="line">        System.out.println(&quot;Window(&quot; + marker + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class House &#123;</span><br><span class="line">    Window w1 = new Window(1);</span><br><span class="line">    House()&#123;</span><br><span class="line">        System.out.println(&quot;House()&quot;);</span><br><span class="line">        w3 = new Window(33);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = new Window(2);</span><br><span class="line">    void f()&#123;</span><br><span class="line">        System.out.println(&quot;f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = new Window(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderOfInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        House h = new House();</span><br><span class="line">        h.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="错误答案"><a href="#错误答案" class="headerlink" title="错误答案"></a>错误答案</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">House()</span><br><span class="line">Window(3)</span><br><span class="line">Window(33)</span><br><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<h2 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h2><p>从主函数出发创建一个House类对象h，构造函数会在创建对象的同时执行，找到House类的构造函数，先输出House()，因为w3是个没被声明的变量，所以先运行了<code>Window w3 = new Window(3)</code>输出Window(3)然后再完成构造函数，输出Window(33)，然后按照顺序完成以下输出。</p>
<h1 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">Window(3)</span><br><span class="line">House()</span><br><span class="line">Window(33)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。在House类中，故意把几个Window对象的定义散布到各处，以整明它们全都会在调用构造器或其他方法之前得到初始化。此外，w3在构造期内再次被初始化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在意识到如果构造函数先执行的话<code>w3 = new Window(33)</code>这一句中的w3是一个没有被声明的变量时就觉得不太对，但还是没有找出正确的思路。后来在尝试别的情况时把这一句注释掉了，输出顺序还是不变，只是少了一句Window(33)。</p>
<hr>
<h1 id="2019-09-06"><a href="#2019-09-06" class="headerlink" title="2019-09-06"></a>2019-09-06</h1><p>今天在学习多态的过程中又遇到了一个初始化顺序的问题，代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Glyph &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Glyph.draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(&quot;Glyph() before draw()&quot;);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(&quot;Glyph() after draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RoundGlyph extends Glyph &#123;</span><br><span class="line">    private int radius = 1;</span><br><span class="line">    RoundGlyph(int r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot; + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;RoundGlyph.draw().radius = &quot; + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PolyConstructors &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new RoundGlyph(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误答案：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw().radius = 1</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph.radius = 5</span><br></pre></td></tr></table></figure></p>
<p>错误思路：<br>首先调用基类构造器，考虑到新创建的对象是RoundGlyph()类的，我认为此处的draw()方法应该已经被覆盖，应该调用子类的draw方法，radius的值在子类中被初始化为1，因此得到了第二行的输出。最后再调用子类构造器的主体，输出第四行。<br>正确答案：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw().radius = 0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph.radius = 5</span><br></pre></td></tr></table></figure></p>
<p>正确思路：除了第二行radius的值以外都对了。初始化的实际过程是：1）在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的0。2）如前所述那样调用基类构造器。此时，调用被覆盖后的draw()方法（需要在调用RoundGlyph构造器之前调用），由于步骤1的缘故，我们此时会发现radius的值为0。3）按照声明的顺序调用成员的初始化方法。4）调用导出类的构造器主体。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：内部类</title>
    <url>/2019/10/17/Java%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：String,StringBuffer和StringBuilder</title>
    <url>/2019/09/25/Java%EF%BC%9AString-StringBuffer%E5%92%8CStringBuilder/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>源码分析：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">        this.value = &quot;&quot;.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Initializes a newly created &#123;@code String&#125; object so that it represents</span><br><span class="line">    * the same sequence of characters as the argument; in other words, the</span><br><span class="line">    * newly created string is a copy of the argument string. Unless an</span><br><span class="line">    * explicit copy of &#123;@code original&#125; is needed, use of this constructor is</span><br><span class="line">    * unnecessary since Strings are immutable.</span><br><span class="line">    *</span><br><span class="line">    * @param  original</span><br><span class="line">    *         A &#123;@code String&#125;</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></p>
<p>String类中每一个看起来会修改String值得方法，实际上都是创建了一个全新的String对象。每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上。这就是为什么我们说String类是不可变的(immutable)。</p>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>源码分析：<br>定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StringBuffer类被final修饰，因此不能继承。<br>此类的父类是AbstractStringBuilder，AbstractStringBuilder类中具体实现了可变字符序列的一系列操作，比如append()、insert()、delete()、replace()、charAt()方法等。<br>此类实现了两个接口，Serializable表示该类的对象可以被序列化，CharSequence的接口提供了几个对字符序列进行只读访问的方法，例如length()、charAt()、subSequence()、toString()方法等。</p>
<p>主要变量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A cache of the last value returned by toString. Cleared</span><br><span class="line">     * whenever the StringBuffer is modified.</span><br><span class="line">     */</span><br><span class="line">    private transient char[] toStringCache;</span><br><span class="line"></span><br><span class="line">// AbstractStringBuilder.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * The value is used for character storage.</span><br><span class="line">     */</span><br><span class="line">    char[] value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * The count is the number of characters used.</span><br><span class="line">     */</span><br><span class="line">    int count;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>toStringCache用来缓存toString()方法返回的最近一次的value数组中的字符。当修改StringBuffer对象时会被清除。</li>
<li><p>value用来存储字符序列中的字符。这是一个动态数组，当存储容量不足时，会对它进行扩容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder(int capacity) &#123;</span><br><span class="line">        value = new char[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count表示value数组中已存储的字符数。<br>StringBuffer类将所有操作字符序列的方法都添加了 synchronized 关键字来修饰，因此，StringBuffer类是线程安全的。</p>
</li>
</ol>
<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder和StringBuffer的源码中，定义和操作几乎都是一样的，唯一的区别是StringBuffer是线程安全的，在单线程的情况下StringBuilder比StringBuffer要快。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：代码复用</title>
    <url>/2019/08/27/Java%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。<br>&emsp;&emsp;实现代码复用的第一种方法：只需在新的类中产生现有类的对象。由于新的类是由现有类的对象所组成，所以这种方法称为组合。<br>&emsp;&emsp;实现代码复用的第二种方法：按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种方式称为<strong>继承</strong>。</p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>&emsp;&emsp;将对象引用置于新类中即可。例如我现在有两个类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Wheel &#123;</span><br><span class="line">    void run()&#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);  // 车轮类的功能是run</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Light &#123;</span><br><span class="line">    void lit() &#123;</span><br><span class="line">        System.out.println(&quot;lit&quot;);  // 车灯类的功能是lit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我现在有一个新的类Car，需要同时有run和lit的功能，此时应当使用组合，这样我就可以在Car类中同时拥有两个类的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    private Wheel wheel;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public Car(Wheel wheel, Light light) &#123;</span><br><span class="line">        this.wheel = wheel;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        wheel.run();</span><br><span class="line">        light.lit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wheel wheel = new Wheel();</span><br><span class="line">        Light light = new Light();</span><br><span class="line">        Car car = new Car(wheel, light);</span><br><span class="line">        car.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="继承与代理"><a href="#继承与代理" class="headerlink" title="继承与代理"></a>继承与代理</h1><p>&emsp;&emsp;Java中的继承是一个类继承另一个类的性质的过程。比如一个新的类我们称之为衍生类或子类，继承了之前就存在的我们称之为父类、超类或者基类的类的属性和行为。<br>&emsp;&emsp;代理仅仅是把任务传递给别的类。</p>
<ul>
<li>代理可以是继承的替代品</li>
<li>代理意味着你将其他类的对象作为实例变量传递信息给指定的实例</li>
<li>很多情况下代理比继承好因为代理让你去考虑你所传递的每个信息，因为实例属于一个已知的类而不是一个新的类，并且不强迫你去接受父类的所有方法：你可以只提供有用的方法</li>
<li>代理可以被看作对象之间的关系因为一个对象转发相应的方法调用给另一个对象，这叫做代理</li>
<li>代理的主要优势是运行时间的灵活性——代理可以很容易地改变运行时间。但是和继承不同，代理并不被主流的面向对象语言所支持，而且它不易于动多态。<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RealPrinter&#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(&quot;The delegate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Printer &#123;</span><br><span class="line">    RealPrinter p = new RealPrinter();</span><br><span class="line"></span><br><span class="line">    void print() &#123;</span><br><span class="line">        p.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Tester &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Printer printer = new Printer();</span><br><span class="line">        printer.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The delegate</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当使用代理时，只需要调用一些必须要用的类，不用关心是怎么实现的，只需要知道你调用的那个类知道要做什么。<br>&emsp;&emsp;同样的代码用继承来实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RealPrinter &#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(&quot;Printing Data&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Printer extends RealPrinter &#123;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        super.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Tester &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Printer printer = new Printer();</span><br><span class="line">        printer.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Printing Data</span><br></pre></td></tr></table></figure></p>
<p>什么时候该用什么？<br>这里举几个例子来说明什么时候用代理什么时候用继承：<br>假设你的类叫B，是A的子类，那么如果：</p>
<ul>
<li>你想表达(is-a)关系，用继承</li>
<li>你想把类直接传递到一个现有的需要A的API那么就用继承</li>
<li>你想改进A，但是A已经是终点并且不能再被继承了，那你就要用组合和代理</li>
</ul>
<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>&emsp;&emsp;首先想一想，组合是怎么工作的。我们把对象引用放在新的类里，这就意味着我们可以通过组合语法，在一个类中拥有多个指向其他类的引用。<br>&emsp;&emsp;其次想一想继承是如何工作的，继承通过extends关键词，可以接过父类中所有的属性和方法，但是由于Java是不支持多继承的，所以一个类只能继承一个父类。<br>&emsp;&emsp;根据特性我们可以总结一下继承和组合的优缺点：<br><strong>继承</strong><br>优点：</p>
<ul>
<li>支持扩展；</li>
<li>被复用的代码易于修改</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类的实现细节都暴露给了子类，破坏了封装性；</li>
<li>当父类代码修改时，子类也要修改，增加了维护的难度；</li>
<li>子类缺乏独立性，与父类的耦合度高；</li>
<li>不支持动态拓展，在编译期就决定了父类。</li>
</ul>
<p><strong>组合</strong><br>优点：</p>
<ul>
<li>被包括的对象内部实现细节对外不可见，封装性好；</li>
<li>整体类与局部类松耦合，相互独立；</li>
<li>支持扩展；</li>
<li>每个类只负责一项业务；</li>
<li>支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建整体类对象时，需要创建所有局部类对象。导致系统对象很多。    </li>
</ul>
<p>&emsp;&emsp;关于代理，《Java编程思想》中对代理有这样一句描述：这是继承与组合之间的中庸之道。在代理类中可以创建某功能的类，调用类的一些方法获得该类的部分特性。比如说我有一个飞机类，飞机有向各个方向运动的方法，还有发射导弹的方法。我可以通过在代理类中只调用（就像组合）运动方法的方法来避免暴露发射导弹的方法，同时代理类中暴露了其他运动的方法（就像继承）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/riskys/article/details/54988442" target="_blank" rel="noopener">csdn</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：接口</title>
    <url>/2019/09/06/Java%EF%BC%9A%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="Java中的多重继承"><a href="#Java中的多重继承" class="headerlink" title="Java中的多重继承"></a>Java中的多重继承</h1><p>在C++中，组合多个类的接口的行为被称作多重继承。<br>接口可以解决Java不能多继承的问题</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：前期绑定和后期绑定</title>
    <url>/2019/08/31/Java%EF%BC%9A%E5%89%8D%E6%9C%9F%E7%BB%91%E5%AE%9A%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="程序绑定"><a href="#程序绑定" class="headerlink" title="程序绑定"></a>程序绑定</h2><p>&emsp;&emsp;绑定指的是一个方法的调用与方法所在的类（方法主体）关联起来。对Java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。</p>
<h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>&emsp;&emsp;编译器在编译的时候就能解析的绑定叫做静态绑定或者前期绑定，Java当中的方法只有final，static和private方法是前期绑定。</p>
<p><strong>为什么static,final和private方法总是静态绑定的？</strong><br>&emsp;&emsp;静态绑定在性能方面更好（不需要额外开销）。编译器知道这些方法不能被重写并且一直都可以被本地类的对象访问。因此编译器很轻松就能确定类的对象（肯定是本地类），所以被这种方法绑定是静态的。<br>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NewClass &#123;</span><br><span class="line">    public static class superclass &#123;</span><br><span class="line">        static void print()&#123;</span><br><span class="line">            System.out.println(&quot;print in superclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class subclass extends superclass &#123;</span><br><span class="line">        static void print() &#123;</span><br><span class="line">            System.out.println(&quot;print in subclass.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        superclass A = new superclass();</span><br><span class="line">        superclass B = new subclass();  // 如果把此处的引用改成subclass，输出的就是&quot;print in subclass&quot;</span><br><span class="line">        A.print();</span><br><span class="line">        B.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print in superclass</span><br><span class="line">print in superclass</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>我们创建了一个subclass的对象和一个superclass的对象，并且引用了superclass</li>
<li>superclass的print方法是静态的，编译器知道它不会在子类中被重写，因此编译器在编译期间知道要调用哪种打印方法，因此不存在歧义</li>
</ul>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>&emsp;&emsp;在动态绑定中编译器不决定调用的方法，因为对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。重写是动态绑定的一个完美例子。在重写中子类和父类都有同样的方法。例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NewClass &#123;</span><br><span class="line">    // 和上一个代码的区别在于print()方法不再static了</span><br><span class="line">    public static class superclass &#123;</span><br><span class="line">        void print()&#123;</span><br><span class="line">            System.out.println(&quot;print in superclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class subclass extends superclass &#123;</span><br><span class="line">        void print() &#123;</span><br><span class="line">            System.out.println(&quot;print in subclass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        superclass A = new superclass();</span><br><span class="line">        superclass B = new subclass();</span><br><span class="line">        A.print();</span><br><span class="line">        B.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print in superclass</span><br><span class="line">print in subclass</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ul>
<li>这个代码中的方法不是静态的</li>
<li>编译过程中，编译器不知道哪一个print方法被调用了，因为编译器只通过引用变量而不是对象类型来引用，于是绑定会被延迟到运行时而且因此对应版本的print会被根据对象类型调用</li>
</ul>
<p><strong>重点</strong></p>
<ul>
<li>private, final和静态成员（方法和变量）用静态绑定，然而对虚拟方法（Java方法默认为虚拟方法）绑定是在运行时基于运行时对象完成的</li>
<li>静态绑定使用类型信息用于绑定然而动态绑定用对象来解析绑定</li>
<li>重载方法通过静态绑定被解析（当有很多个同名方法时决定调用哪一个）然而重写方法用动态绑定</li>
</ul>
<hr>
<p>Q：<br>以下代码中发生了什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Animal is eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Dog is eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">    Animal a=new Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A：<br>这个例子是一个动态绑定，因为a的类型实在运行时被确定的，于是相似的方法被调用了<br>现在假设有以下两个方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void callEat(Animal animal) &#123;</span><br><span class="line">    System.out.println(&quot;Animal is eating&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void callEat(Dog dog) &#123;</span><br><span class="line">    System.out.println(&quot;Dog is eating&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把main方法改成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">    Animal a = new Dog();</span><br><span class="line">    callEat(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出会是<code>Animal is eating</code>，因为对<code>callEat</code>的调用是静态绑定，编译器只知道a是一种Animal。</p>
<hr>
<p>参考</p>
<blockquote>
<p><a href="https://www.geeksforgeeks.org/static-vs-dynamic-binding-in-java/" target="_blank" rel="noopener">Geeksforgeeks</a><br><a href="https://stackoverflow.com/questions/16647590/static-binding-and-dynamic-binding" target="_blank" rel="noopener">stackoverflow</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：隔离岛</title>
    <url>/2019/08/24/Java%EF%BC%9A%E9%9A%94%E7%A6%BB%E5%B2%9B/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在Java中，对象的销毁由GC(垃圾收集器)模块负责，并且那些没有被引用的对象是可以被垃圾收集的，垃圾收集器能够识别这类的对象。<br>&emsp;&emsp;隔离岛：<br>&emsp;&emsp;- 对象1引用对象2和对象2引用对象1.对象1和对象2都不被任何其他对象引用。<br>&emsp;&emsp;- 通常来说隔离岛是一组互相引用但不被应用程序中其它活动的对象引用的对象。严格来说，即使一个没有被引用的对象也是一个隔离岛。<br>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    Test i;  // 类里定义了一个对象引用</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test t1 = new Test();</span><br><span class="line">        Test t2 = new Test();</span><br><span class="line"></span><br><span class="line">        t1.i = t2;</span><br><span class="line">        t2.i = t1;</span><br><span class="line">        t1 = null;</span><br><span class="line">        t2 = null;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable&#123;</span><br><span class="line">        System.out.println(&quot;Finalize method called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Finalize method called</span><br><span class="line">Finalize method called</span><br></pre></td></tr></table></figure></p>
<p>分析:<br>&emsp;&emsp;在销毁一个对象之前，垃圾收集器对一个对象最多调用一次finalize方法,在上例中finalize方法被调用两次的理由是因为两个对象都有资格被垃圾收集。这是因为我们在执行<code>t2=null</code>之后没有任何对t1和t2的外部引用。<br>&emsp;&emsp;我们只有内部的互相引用(在Test类的实例变量i中)。我们没有办法去调用两个对象的实例变量。所以不能再次调用任何一个对象。<br>&emsp;&emsp;我们在Test类里面创建了一个属性Test i，主函数中创建了两个Test类型的对象，并且用两个引用t1和t2去指向这两个对象，然后通过t1.i去访问t2，通过t2.i去访问t1，直到t2.i = t1: 每个对象都有外部引用t1和t2。这里需要记住的是t1和t2仅仅是引用，真正的对象在图中是以圈表示的,下图中t1指向一个对象，这个对象中有属性i，通过t1这个对象的属性i指向另一个对象，也就是t2指向的对象，反之亦然：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_1.png" alt><br>&emsp;&emsp;t1 = null: 此时引用t1已经不指向任何对象，但是对象还是存在的，只不过通过t2.i可以到达之前t1指向的对象，通过t2可以直接访问另一个对象：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_11.png" alt><br>&emsp;&emsp;t2 = null: 分析过程和上一步相同，此时没有办法到达任何一个对象：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_12.png" alt><br>&emsp;&emsp;现在，两个对象都有资格被垃圾收集，因为我们没有办法调用他们了。这通常被称为隔离岛。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://www.geeksforgeeks.org/island-of-isolation-in-java/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：封装</title>
    <url>/2020/05/26/Java%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h4 id="Q-What-is-the-difference-between-abstraction-and-encapsulation"><a href="#Q-What-is-the-difference-between-abstraction-and-encapsulation" class="headerlink" title="Q. What is the difference between abstraction and encapsulation?"></a>Q. <strong><em>What is the difference between abstraction and encapsulation?</em></strong></h4><ul>
<li>Abstraction solves the problem at design level while Encapsulation solves it implementation level. </li>
<li>In Java, Abstraction is supported using <code>interface</code> and <code>abstract class</code> while Encapsulation is supported using access modifiers e.g. public, private and protected.</li>
<li>Abstraction is about hiding unwanted details while giving out most essential details, while Encapsulation means hiding the code and data into a single unit e.g. class or method to protect inner working of an object from outside world. </li>
</ul>
<table class="alt">
<tbody><tr><th>Abstraction</th><th>Encapsulation</th></tr>
<tr><td>Abstraction is a process of hiding the implementation details and showing only functionality to the user.</td>
<td> Encapsulation is a process of wrapping code and data together into a single unit</td></tr>
<tr><td>Abstraction lets you focus on what the object does instead of how it does it.</td>
<td>Encapsulation provides you the control over the data and keeping it safe from outside misuse.</td></tr>
<tr><td>Abstraction solves the problem in the Design Level.</td>
<td>Encapsulation solves the problem in the Implementation Level.</td></tr>
<tr><td>Abstraction is implemented by using Interfaces and Abstract Classes.</td>
<td>Encapsulation is implemented by using Access Modifiers (private, default, protected, public)</td></tr>
<tr><td>Abstraction means hiding implementation complexities by using interfaces and abstract class.</td>
<td>Encapsulation means hiding data by using setters and getters.</td></tr>
</tbody></table>

<div align="right">
    <b><a href="#">↥ back to top</a></b>
</div>

<h4 id="Q-How-Encapsulation-concept-implemented-in-JAVA"><a href="#Q-How-Encapsulation-concept-implemented-in-JAVA" class="headerlink" title="Q. How Encapsulation concept implemented in JAVA?"></a>Q. <strong><em>How Encapsulation concept implemented in JAVA?</em></strong></h4><p>Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as <code>data hiding</code>.</p>
<p>To achieve encapsulation in Java −  </p>
<ul>
<li>Declare the variables of a class as private.</li>
<li>Provide public setter and getter methods to modify and view the variables values.</li>
</ul>
<p>Example:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncapClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String newName)</span> </span>&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      EncapClass obj = <span class="keyword">new</span> EncapClass();</span><br><span class="line">      obj.setName(<span class="string">"Pradeep Kumar"</span>);</span><br><span class="line">      System.out.print(<span class="string">"Name : "</span> + obj.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div align="right">
    <b><a href="#">↥ back to top</a></b>
</div>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：泛型</title>
    <url>/2019/10/21/Java%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>第一次在《Java编程思想》中接触到泛型这个概念是在第十一章中，这一章讲的是持有对象。<br>首先来看一份没有使用泛型的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Apple &#123;</span><br><span class="line">    private static long counter;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line">    public long id() &#123; return id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Orange &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ApplesAndOrangesWithoutGenerics &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList apples = new ArrayList();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            apples.add(new Apple());</span><br><span class="line">        apples.add(new Orange());</span><br><span class="line">        for(int i = 0; i &lt; apples.size(); i++)</span><br><span class="line">            ((Apple)apples.get(i)).id();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码分析：<br>首先定义两个类（Apple和Orange），两个类除了都默认继承自Object类之外没有任何共性。<br>主函数中尝试将三个Apple对象和一个Orange对象放入容器<code>ArrayList apples</code>中，使用了@SuppressWarnings注解及其参数表示只有有关“不受检查的异常”的警告信息应该被抑制。<br>最后一个for循环用于获取容器apples中的对象的id。<br>运行结果：<br>报错信息<code>holding.Orange cannot be cast to holding.Apple</code>，Orange类型不能转型为Apple类型</p>
<p>然后来看一份使用了泛型的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class ApplesAndOrangesWithGenerics &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Apple&gt; apples =  new ArrayList&lt;Apple&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            apples.add(new Apple());</span><br><span class="line">//        apples.add(new Orange());</span><br><span class="line">        for (int i = 0; i &lt; apples.size(); i++)</span><br><span class="line">            System.out.println(apples.get(i));</span><br><span class="line">        for (Apple c : apples)</span><br><span class="line">            System.out.println(c.id());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码分析：<br>执行的操作和之前的代码一样，区别在于初始化容器时<code>ArrayList</code>后面加了一个<code>&lt;Apple&gt;</code>，尖括号括起来的是类型参数（可以有多个），它指定了这个容器实例可以保存的类型。在此处我将添加Orange对象到容器注释掉了，因为它在编译期就会报错，而上一份代码在运行时才能看出错误。</p>
<h1 id="个人理解-2019-10-21"><a href="#个人理解-2019-10-21" class="headerlink" title="个人理解(2019-10-21)"></a>个人理解(2019-10-21)</h1><p>因为目前还没有对泛型进行深入的学习，所以仅仅通过上面的代码我个人对泛型的理解类似于方法的形参，编译期就规定好了容器内对象的类型，这样可以减少运行时错误（变成编译期错误）。并且注意到在将元素从List中取出时，类型转换也不再是必须的了。因为List知道它保存的是什么类型，因此它会在调用get()时替你执行转型。这样，通过使用泛型，你不仅知道编译器将会检查你放置到容器中的对象类型，而且在使用容器中的对象时，可以使用更加清晰的语法。<br>后续深入学习泛型后再做补充。</p>
<hr>
<h4 id="Q-Do-you-know-Generics-How-did-you-used-in-your-coding"><a href="#Q-Do-you-know-Generics-How-did-you-used-in-your-coding" class="headerlink" title="Q. Do you know Generics? How did you used in your coding?"></a>Q. <strong><em>Do you know Generics? How did you used in your coding?</em></strong></h4><p><code>Generics</code> allows type (Integer, String, … etc and user defined types) to be a parameter to methods, classes and interfaces. For example, classes like HashSet, ArrayList, HashMap, etc use generics very well.</p>
<p><strong>Advantages</strong></p>
<ul>
<li><strong>Type-safety</strong>: We can hold only a single type of objects in generics. It doesn’t allow to store other objects.</li>
<li><strong>Type Casting</strong>: There is no need to typecast the object.</li>
<li><strong>Compile-Time Checking</strong>: It is checked at compile time so problem will not occur at runtime.</li>
</ul>
<p>Example:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* A Simple Java program to show multiple </span></span><br><span class="line"><span class="comment">* type parameters in Java Generics </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* We use &lt; &gt; to specify Parameter type</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123; </span><br><span class="line">    T obj1;  <span class="comment">// An object of type T </span></span><br><span class="line">    U obj2;  <span class="comment">// An object of type U </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// constructor </span></span><br><span class="line">    GenericClass(T obj1, U obj2) &#123; </span><br><span class="line">        <span class="keyword">this</span>.obj1 = obj1; </span><br><span class="line">        <span class="keyword">this</span>.obj2 = obj2; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// To print objects of T and U </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(obj1); </span><br><span class="line">        System.out.println(obj2); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver class to test above </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        GenericClass &lt;String, Integer&gt; obj = </span><br><span class="line">            <span class="keyword">new</span> GenericClass&lt;String, Integer&gt;(<span class="string">"Generic Class Example !"</span>, <span class="number">100</span>); </span><br><span class="line">  </span><br><span class="line">        obj.print(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generic Class Example !</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p>
<div align="right">
    <b><a href="#">↥ back to top</a></b>
</div>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：集合</title>
    <url>/2019/11/01/Java%EF%BC%9A%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Collection和Map接口"><a href="#Collection和Map接口" class="headerlink" title="Collection和Map接口"></a>Collection和Map接口</h1><p>Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：Collection和Map。<br>书中提到这样一行代码<code>List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;</code>并配上说明：ArrayList向上转型为List。读到这里我很迷惑，难道不是所有的容器都继承自Collection或者Map接口吗，为什么还会有一个List是ArrayList的父类呢？<br>通过查找资料得到这样两张图表述了Collection和Map两个大接口及其子接口的关系。<br><img src="//xiaokeliu666.github.io/2019/11/01/Java：集合/Collection.jpg" alt><br><img src="//xiaokeliu666.github.io/2019/11/01/Java：集合/Map.jpg" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：静态代码块、非静态代码块、构造函数以及Java类初始化顺序</title>
    <url>/2019/09/07/Java%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8AJava%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>&emsp;&emsp;今天在做笔试题时遇到这样一个问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        static Test t1 = new Test();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockB&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test t2 = new Test();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在以上代码中涉及到了静态代码块、构造代码块，之前没接触过这个概念，所以查资料记录学习了一下。</p>
<h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><h2 id="什么是静态代码块？"><a href="#什么是静态代码块？" class="headerlink" title="什么是静态代码块？"></a>什么是静态代码块？</h2><p>写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="它有什么特点？"><a href="#它有什么特点？" class="headerlink" title="它有什么特点？"></a>它有什么特点？</h2><ul>
<li>用static申明，JVM加载类时执行，仅执行一次，执行完成便销毁。</li>
<li>静态代码块的执行优先级高于非静态的初始化块。</li>
</ul>
<h1 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h1><h2 id="什么是构造代码块？"><a href="#什么是构造代码块？" class="headerlink" title="什么是构造代码块？"></a>什么是构造代码块？</h2><p>写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="它有什么特点？-1"><a href="#它有什么特点？-1" class="headerlink" title="它有什么特点？"></a>它有什么特点？</h2><p>&emsp;&emsp;构造代码块的作用是给对象进行初始化，只有当对象创建才会执行，且执行顺序优于构造函数。并且不同于构造函数，构造代码块针对所有的对象，而构造函数针对对应的对象。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>&emsp;&emsp;构造函数只有在建立对象的时候在会调用与之相应的构造函数，不建立对象是不会运行构造函数的。一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>静态块其实就是给类初始化的，而构造代码块是给对象初始化的。</li>
<li>静态代码块只会运行一次</li>
<li>静态块中的变量是局部变量，与普通函数中的局部变量性质没有区别。</li>
<li>一个类中可以有多个静态代码块，执行顺序按照位置决定。</li>
<li>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法</li>
</ol>
<hr>
<p>回到上面的问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        static Test t1 = new Test();</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;blockB&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test t2 = new Test();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockA</span><br><span class="line">blockB</span><br><span class="line">blockA</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>&emsp;&emsp;t1也是静态变量，所以按照声明顺序执行，先创建对象t1，运行其构造代码块，输出blockA，之后运行静态代码块，输出blockB，最后运行main函数。</p>
<hr>
<p>创建对象时得调用顺序：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java: String</title>
    <url>/2020/05/26/Java-String/</url>
    <content><![CDATA[<h4 id="Q-Why-string-is-immutable-in-java"><a href="#Q-Why-string-is-immutable-in-java" class="headerlink" title="Q. Why string is immutable in java?"></a>Q. <strong><em>Why string is immutable in java?</em></strong></h4><p>The string is Immutable in Java because String objects are cached in String pool. Since cached String literals are shared between multiple clients there is always a risk, where one client’s action would affect all another client. </p>
<p>Since string is immutable it can safely share between many threads and avoid any synchronization issues in java.</p>
<h4 id="Q-What-is-Java-String-Pool"><a href="#Q-What-is-Java-String-Pool" class="headerlink" title="Q. What is Java String Pool?"></a>Q. <strong><em>What is Java String Pool?</em></strong></h4><p>String Pool in java is a pool of Strings stored in Java Heap Memory. String pool helps in saving a lot of space for Java Runtime although it takes more time to create the String.</p>
<p>When we use double quotes to create a String, it first looks for String with the same value in the String pool, if found it just returns the reference else it creates a new String in the pool and then returns the reference. However using <strong>new</strong> operator, we force String class to create a new String object in heap space.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Java program to illustrate String Pool</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Java"</span>;</span><br><span class="line">        String s2 = <span class="string">"Java"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span> +(s1==s2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span> +(s1==s3)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:20.Valid Parentness</title>
    <url>/2019/12/28/LeetCode-20-Valid-Parentness/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<pre><code>1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
</code></pre><p>Note that an empty string is also considered valid.</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Based on the property of FILO, stack can help with match the brackets. I only push the left half of bracket and when it comes to a right part of bracket, I use it to match the top of stack, if success, pop the element, if fail, return false.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>class Solution {<br>    public boolean isValid(String s) {<br>        Stack<character> stack = new Stack();<br>        char[] stringArr = s.toCharArray();<br>        int len = s.length();<br>        int i = 0;<br>        String temp;<br>        for (i = 0; i &lt; len; i++) {<br>            try {<br>                if (stringArr[i] == ‘(‘ || stringArr[i] == ‘[‘ || stringArr[i] == ‘{‘) {<br>                    stack.push(stringArr[i]);<br>                } else if (‘(‘ == stack.peek() &amp;&amp; stringArr[i] == ‘)’ || ‘[‘ == stack.peek() &amp;&amp; stringArr[i] == ‘]’ || ‘{‘ == stack.peek() &amp;&amp; stringArr[i] == ‘}’) {<br>                    stack.pop();<br>                } else {<br>                    return false;<br>                }<br>            } catch (Exception e) {<br>                return false;<br>            }<br>        }<br>        return stack.empty();</character></p>
<pre><code>}
</code></pre><p>}</p>
<h1 id="Better-Solution"><a href="#Better-Solution" class="headerlink" title="Better Solution"></a>Better Solution</h1><p>When it comes to the left half of bracket, push its right part into a stack.<br>When it comes to the right half of bracket, match it with the top of stack(pop it if match).<br>At last check the emptiness of stack</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><p>public boolean isValid(String s) {<br>    Stack<character> stack = new Stack<character>();<br>    for (char c : s.toCharArray()) {<br>        if (c == ‘(‘)<br>            stack.push(‘)’);<br>        else if (c == ‘{‘)<br>            stack.push(‘}’);<br>        else if (c == ‘[‘)<br>            stack.push(‘]’);<br>        else if (stack.isEmpty() || stack.pop() != c)<br>            return false;<br>    }<br>    return stack.isEmpty();<br>}</character></character></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode:26.Remove Duplicates from Sorted Array</title>
    <url>/2019/11/04/LeetCode-26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h1 id="Wrong-Code"><a href="#Wrong-Code" class="headerlink" title="Wrong Code"></a>Wrong Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int c = nums.length;</span><br><span class="line">    for(int i = 0; i &lt; nums.length-1; i++)&#123;</span><br><span class="line">        if (nums[i] == nums[i+1])</span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-Information"><a href="#Error-Information" class="headerlink" title="Error Information"></a>Error Information</h2><p>Your input [1,1,2]<br>Output [1,1]<br>Expected [1,2]</p>
<h2 id="Wrong-Thinking"><a href="#Wrong-Thinking" class="headerlink" title="Wrong Thinking"></a>Wrong Thinking</h2><p>I ignored the requirement that requirement of removing the duplicates, and I worte this only to return the length of array without duplicates which means the array wasn’t changed actually.</p>
<h1 id="How-Did-I-Correct-the-Code"><a href="#How-Did-I-Correct-the-Code" class="headerlink" title="How Did I Correct the Code"></a>How Did I Correct the Code</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>The reason why i was wrong is not doing the modification on array. Besides return the length of array without duplicates, I still have to change the order of digits in the array.</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Considering the size of an array cannot change, and the clarification in the example said “It doesn’t matter what values are set beyond the returned length”, so what I have to do is move the digit towards if it didn’t show up before and put the repeated digit backward.<br>Obviously, the first digit is unchanged no matter how does array look like since the array is sorted. We can start from the second one whose index is 1.<br>We can use two cursors: index and i, and both of index and i starts from the value of 1. Then we set a loop, when we get into the loop, compare the nums[i] with nums[i-1], if they are the same, i move to the next digit while index doesn’t move, otherwise the nums[index] will be updated with the value of nums[i] and both of i and index move to the next digit.<br>The advantage of this method is we can guarantee that the order before the index is always right and no duplicates. </p>
<h2 id="Right-Code"><a href="#Right-Code" class="headerlink" title="Right Code"></a>Right Code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int index = 1;</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] == nums[i-1])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index] = nums[i];</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:53.Maximum Subarray</title>
    <url>/2019/11/06/LeetCode-53-Maximum-Subarray/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<h1 id="Wrong-Code"><a href="#Wrong-Code" class="headerlink" title="Wrong Code"></a>Wrong Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int sum = nums[0];</span><br><span class="line">    for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        for (int j=i+1; j&lt;nums.length; j++)&#123;</span><br><span class="line">            temp += nums[j];</span><br><span class="line">            if(temp&gt;sum)&#123;</span><br><span class="line">                sum = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-Information"><a href="#Error-Information" class="headerlink" title="Error Information"></a>Error Information</h2><p>Input [-2,1]<br>Output -1<br>Expected 1</p>
<h2 id="Wrong-Thinking"><a href="#Wrong-Thinking" class="headerlink" title="Wrong Thinking"></a>Wrong Thinking</h2><p>My program will stop entering the second layer loop when i = nums.length-1 which refer to the last digit. In this situation, when the sum has already been decided and cannot be changed anymore. So I have take this situation into account.</p>
<h1 id="Correct-Code"><a href="#Correct-Code" class="headerlink" title="Correct Code"></a>Correct Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int sum = nums[0];</span><br><span class="line">        for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">            int temp = nums[i];</span><br><span class="line">            if(temp&gt;sum)&#123;</span><br><span class="line">                sum = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j=i+1; j&lt;nums.length; j++)&#123;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">                if(temp&gt;sum)&#123;</span><br><span class="line">                    sum = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>Just take the situation into account and add another statement in the first layer loop</p>
<h1 id="Better-Code"><a href="#Better-Code" class="headerlink" title="Better Code"></a>Better Code</h1><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p>Usually problem about optimization can be solved by dynamic programming. As for DP, the most important thing is finding the recursion within the problem.<br>In terms of this problem, we define the problem as <code>maxSubArray(int A[],int i)</code>. Assume we have the result of problem<code>maxSubArray(A, i-1)</code>, we can get a equation as:<br><code>maxSubArray(A,i) = maxSubArray(A,i-1)&gt;0?maxSubArray(A,i-1):0+A[i];</code><br>In short, if you know the solution of the maxSubArray which ends up with index i-1, there are two choices: 1. Start a new subarray from index i; 2. Expand the previous subarray with index i.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        int cmp = res;</span><br><span class="line">        for(int i = 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = cmp;</span><br><span class="line">            res = Math.max(res+nums[i],nums[i]);</span><br><span class="line">            cmp = Math.max(res, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>res: biggest value if subarray ends up with nums[i]<br>cmp: biggest value so far</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:27.Remove Element</title>
    <url>/2019/11/06/LeetCode-27-Remove-Element/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>Same as the Question 26, change the array and only part of them is required.<br>Try the same thinking as Question 26.<br>Use two cursors, 1(int index) is for index and 1(int i) is for going through all the elements.<br>If only the nums[i] does not equal to the target value, put it at the nums[index]</p>
<h1 id="Right-Code"><a href="#Right-Code" class="headerlink" title="Right Code"></a>Right Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] != val) &#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:199</title>
    <url>/2020/05/15/LeetCode-199/</url>
    <content><![CDATA[<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,res,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void helper(TreeNode root, List&lt;Integer&gt; res, int level) &#123;</span><br><span class="line">        if(root==null) &#123;return;&#125;</span><br><span class="line">        if(res.size()==level) &#123;res.add(root.val);&#125;</span><br><span class="line">        helper(root.right,res,level+1);</span><br><span class="line">        helper(root.left,res,level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到会出现树不平衡的情况:<br>               1<br>            /    \\<br>           2      3<br>           \\<br>            5<br>所以既要考虑到左边的子树，也要考虑到右边的子树。此例中如果每次递归都只考虑最右边的子树的节点，会发现3没有子节点，这时候就没办法回到2节点了。<br>这种解法的技巧在于用level来确保每一层只会选取一个节点。先递归右子树再递归左子树则解决了不平衡的问题：如果右子树没了，再考虑同一层的左子树。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:35.Search Insert Position</title>
    <url>/2019/11/06/LeetCode-35-Search-Insert-Position/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><ol>
<li>Going through the array</li>
<li>Try to find an index i where nums[i] == target and return the i</li>
<li>If step 2 failed, try to find an index i where nums[i] &gt; target. Notieced that the array is sorted and if we have to insert a digit before nums[i], the index of the digit should be i as well, then we have to break from the loop, otherwise the position will be wrong</li>
<li>There is a possibility that the target is bigger than the biggest one in the array, then the index to insert should be the value of nums.length.</li>
</ol>
<h1 id="Right-Code"><a href="#Right-Code" class="headerlink" title="Right Code"></a>Right Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i] == target || nums[i] &gt; target)&#123;</span><br><span class="line">            res = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res = nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode: 1.Two Sum</title>
    <url>/2019/09/20/LeetCode-1-Two-Sum/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<h1 id="Wrong-Code"><a href="#Wrong-Code" class="headerlink" title="Wrong Code"></a>Wrong Code</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i =0; i &lt;nums.length; i++)&#123;</span><br><span class="line">            hashMap.put(nums[i], i);</span><br><span class="line">            if(hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[0] = i;</span><br><span class="line">                res[1] = hashMap.get(target-nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-Information"><a href="#Error-Information" class="headerlink" title="Error Information"></a>Error Information</h2><p>When nums= [3, 3], target = 6，expected outcome is[0, 1]，but [1, 1].</p>
<h2 id="Wrong-Thinking"><a href="#Wrong-Thinking" class="headerlink" title="Wrong Thinking"></a>Wrong Thinking</h2><p>I was trying to store the array into a hashmap. Considering that hashmap can only get value from key, so I put the value of array at the place of K while incremental i is V.<br>Then reason why I was wrong was not considering the situation of repeated numbers. During the debugging I found that the size of hashMap is 1 when the nums=[3,3] which means key is unique in hashMap.</p>
<h1 id="How-Did-I-Correct-the-Code"><a href="#How-Did-I-Correct-the-Code" class="headerlink" title="How Did I Correct the Code"></a>How Did I Correct the Code</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>The key of making mistake is ignoring the situation of repeated numbers in array, so directely transform array into hashmap by reversing the index to value  is not feasible since the repeated numbers won’t be stored twice in hashmap as a key.</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Given that the input would have exactly one solution, and the same element won’t be used twice, situation like multi-resolution and non-resolution will not be considered.<br>Because hashMap can get value by key, we still need hashmap to do this but in another way.<br>Instead of transforming the array into hashmap one time, I decide to use <code>hashMap.containskey(target-nums[i])</code> to search the hashmap, if returns false, then I put this number into the hashmap instead, otherwise we can get the right answer.<br>If the number is repeated but still cannot find the answer, then it means the resolution is not unique which doesn’t obey the rule of question. For example: nums = [3, 3, 6], target = 9. Obviously, the solution is not unique.</p>
<h2 id="Right-Code"><a href="#Right-Code" class="headerlink" title="Right Code"></a>Right Code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if (hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[0] = hashMap.get(target - nums[i]);</span><br><span class="line">                res[1] = i;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                hashMap.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:94 &amp; 145 &amp; 144</title>
    <url>/2020/05/16/LeetCode-94-145-144/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94.Binary Tree Inorder Traversal"></a>94.Binary Tree Inorder Traversal</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        if(root==null) &#123;return new ArrayList&lt;&gt;();&#125;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void helper(TreeNode root, List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root==null) &#123;return;&#125;</span><br><span class="line">        helper(root.left,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144.Binary Tree Preorder Traversal"></a>144.Binary Tree Preorder Traversal</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void helper(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        if(root==null) &#123;return;&#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.left,res);</span><br><span class="line">        helper(root.right,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145.Binary Tree Postorder Traversal"></a>145.Binary Tree Postorder Traversal</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void helper(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        if(root==null) &#123;return;&#125;</span><br><span class="line">        helper(root.left,res);</span><br><span class="line">        helper(root.right,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>递归方法只需要根据要求改变递归的顺序即可，当递归执行到空节点时返回即可，res.add()保证了每次递归都会添加当前节点，通过调整位置来实现不同序的遍历。</p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><ul>
<li>时间复杂度：O(n)。递归函数 T(n) = 2T(n/2)+1。</li>
<li>空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:98</title>
    <url>/2020/05/16/LeetCode-98/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root==null) &#123;return true;&#125;</span><br><span class="line">        return helper(root,Long.MAX_VALUE,Long.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean helper(TreeNode root, long max, long min) &#123;</span><br><span class="line">        if(root==null) &#123;return true;&#125;</span><br><span class="line">        if(root.val&gt;min &amp;&amp; root.val&lt;max)&#123;</span><br><span class="line">            return helper(root.left,root.val,min) &amp; helper(root.right,max,root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用左节点小于根节点，右节点大于根节点的性质，不断更新max和min的值，来限定当前节点值的范围，使用Long的原因是因为有些奇怪的测试用例，比如：[2147483647]。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:association</title>
    <url>/2020/04/10/MyBatis-association/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>创建student表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">     `id` INT(10) NOT NULL,</span><br><span class="line">     `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">     `tid` INT(10) DEFAULT NULL,</span><br><span class="line">     PRIMARY KEY (`id`),</span><br><span class="line">     KEY `fktid` (`tid`),</span><br><span class="line">     CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)</span><br><span class="line">     ) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p>
<p>创建teacher表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">     `id` INT(10) NOT NULL,</span><br><span class="line">     `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">     PRIMARY KEY (`id`)</span><br><span class="line">     )ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>查询 学生学号，学生姓名，老师姓名</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select s.id ,s.name ,t.name</span><br><span class="line">from student s,teacher t</span><br><span class="line">where s.tid=t.id</span><br></pre></td></tr></table></figure>
<h1 id="MyBatis实现"><a href="#MyBatis实现" class="headerlink" title="MyBatis实现"></a>MyBatis实现</h1><h2 id="实体类-pojo"><a href="#实体类-pojo" class="headerlink" title="实体类(pojo)"></a>实体类(pojo)</h2><p>Student.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    &lt;!-- getter,setter,toString --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q：为什么学生属性中用Teacher teacher而不是int tid？<br>A：如果写int tid就相当于写“死”了，没有达到学生和老师关联的效果。<br>Teacher.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    &lt;!-- getter,setter,toString --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="StudentMapper-xml"><a href="#StudentMapper-xml" class="headerlink" title="StudentMapper.xml"></a>StudentMapper.xml</h2><h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;</span><br><span class="line">    select s.id sid,s.name sname,t.name tname</span><br><span class="line">    from student s, teacher t</span><br><span class="line">    where s.tid=t.id;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;</span><br><span class="line">    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>思路就是先写好SQL语句，再用resultMap去解释里面的内容。<br>Student类中的属性id对应结果中的sid，属性name对应结果中的sname。<br>属性teacher由于是一个复杂属性，所以用association，这里有一种递进的感觉：第一层说明属性teacher的类型是Teacher，第二层说明teacher对象的name属性对应结果中的tname。<br>查询中子集有相同字段取出的数据就会有问题，因此要采用别名的形式。</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>先查询所有学生的信息，再根据查询出来的学生的tid，寻找对应的老师<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查询所有学生 --&gt;</span><br><span class="line">&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">    select * from student;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上下两个select中建立连接 --&gt;</span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据id查询老师 --&gt;</span><br><span class="line">&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt;</span><br><span class="line">    select * from teacher where id=#&#123;tid&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>复杂的属性（Teacher）需要单独处理，如果是一个对象就用 Association，此处为Teacher对象。<br><strong>property=”teacher”</strong>：学生类里的属性叫teacher<br><strong>column=”tid”</strong>：数据库里的字段叫tid<br><strong>javaType=”Teacher”</strong>：因为属性是个复杂类型，所以要给它定义类型Teacher<br><strong>select=”getTeacher”</strong>：嵌套查询,getTeacher为下面select的id</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>ResultMap标签中的COLUMN字段对应的不是数据库表中的字段名，而是select语句返回的字段名，当字段有重复时应对其进行重命名</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:95</title>
    <url>/2020/05/16/LeetCode-95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;TreeNode&gt; generateTrees(int n) &#123;</span><br><span class="line">        if(n&lt;=0) &#123;return new ArrayList&lt;&gt;();&#125;</span><br><span class="line">        return helper(1,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static List&lt;TreeNode&gt; helper(int start, int end) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(end&lt;start) &#123;res.add(null);&#125;</span><br><span class="line">        for(int i = start; i&lt;=end; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftList = helper(start,i-1);</span><br><span class="line">            List&lt;TreeNode&gt; rightList = helper(i+1,end);</span><br><span class="line">            for(TreeNode leftNode:leftList) &#123;</span><br><span class="line">                for(TreeNode rightNode:rightList) &#123;</span><br><span class="line">                    // 为了避免重复的答案，在循环中新建一个root</span><br><span class="line">                    TreeNode root = new TreeNode(i);</span><br><span class="line">                    root.left = leftNode;</span><br><span class="line">                    root.right = rightNode;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定根节点</li>
<li>小于根节点的值生成左子树，大于根节点的值生成右子树</li>
<li>左子树和右子树进行排列组合</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode:96</title>
    <url>/2020/05/16/LeetCode-96/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        if(n==0) &#123;return 0;&#125;</span><br><span class="line">        int[] res = new int[n+1];</span><br><span class="line">        res[0] = 1;</span><br><span class="line">        res[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; n+1; i++) &#123;</span><br><span class="line">            for(int j = 1; j&lt;= i; j++) &#123;</span><br><span class="line">                res[i] += res[i-j] * res[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定一个根节点</li>
<li>小于根节点的值组成左子树，大于根节点的值组成右子树</li>
<li>左子树的组合总数乘以右子树的组合总数，即为当前根节点可能形成的树的总数。</li>
</ol>
<p>举例：<br>当n=6，选取根节点为i=3的时候，此时树的可能性为[1,2]组成子树的可能<em>[4,5,6]组成子树的可能,实际上[4,5,6]组成子树的总数就等于[1,2,3]组成子树的总数。<br>因此可以得出dp公式 F(i, n) = G(i-1) </em> G(n-i)，其中G(i-1)就是左子树，G(n-i)就是右子树。</p>
<hr>
<p>参考：<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i" target="_blank" rel="noopener">https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i</a>) 下用户@lizhu5058的解释。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:二级缓存</title>
    <url>/2020/04/11/MyBatis-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存。</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存。</li>
<li>工作机制：<ul>
<li>一个会话查询一个数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的绘画查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查处的数据会放在自己对应的缓存(map)中</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>config.xml中开启全局缓存，虽然默认就是开启的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--        显式地开启全局缓存--&gt;</span><br><span class="line">        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在SQL映射文件中添加标签并配置参数，也可以不配置，只写一个<code>&lt;cache/&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">    &lt;!-- 清除策略FIFO --&gt;</span><br><span class="line">    eviction=&quot;FIFO&quot;</span><br><span class="line">    &lt;!-- 每隔60秒刷新 --&gt;</span><br><span class="line">    flushInterval=&quot;60000&quot;</span><br><span class="line">    &lt;!-- 最多可以存储结果对象或列表的 512 个引用 --&gt;</span><br><span class="line">    size=&quot;512&quot;</span><br><span class="line">    &lt;!-- 返回的对象被认为是只读的 --&gt;</span><br><span class="line">    readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:resultMap</title>
    <url>/2020/01/22/MyBatis-resultMap/</url>
    <content><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前学习所用到的代码相关内容如下：</p>
<ul>
<li>数据库：表中字段为id, name, pwd</li>
<li>实体类：id, name, pwd</li>
<li><p>UserMapper.xml: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>通过这种UserMapper.xml的配置可以实现通过Id取用户信息的需求。<br>假设现在我保持其它不变，更改实体类为: id, name, password，重新启动测试。输出内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User&#123;id=1, name=&apos;张三&apos;, password=&apos;null&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到password的输出为空。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>类型处理器会自动转译属性名，因此<code>select * from mybatis.user where id = #{id}</code>这段Sql代码的转译过后应该是<code>select id,name,pwd from mybatis.user where id = #{id}</code></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="别名-不推荐"><a href="#别名-不推荐" class="headerlink" title="别名(不推荐)"></a>别名(不推荐)</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="resultMap结果集映射"><a href="#resultMap结果集映射" class="headerlink" title="resultMap结果集映射"></a>resultMap结果集映射</h2><p>原来的结果是：id  name  pwd<br>实体类是: id name  password</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- UserMap是随意取的名字，用来与下面select标签中的resultMap对应 --&gt;</span><br><span class="line">  &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;</span><br><span class="line">  &lt;!-- column数据库中的字段，property实体类中的属性 --&gt;</span><br><span class="line">      &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">  &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt;</span><br><span class="line">      select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。简单的语句就是我们原本的代码，直接使用Sql语句就能完成映射。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode:105 &amp; 106</title>
    <url>/2020/05/16/Leetcode-105-106/</url>
    <content><![CDATA[<p>前序遍历：根-左-右<br>中序遍历：左-根-右<br>后序遍历：右-左-根<br>前序遍历和后续遍历可以确定根节点的位置（第一个或最后一个），中序遍历可以确定左子树上有哪些节点，右子树上有哪些节点。这两道题的大致思路就是通过前序或者后序遍历，确定根节点的位置，再通过中序遍历确定左右两边子树的节点，依次迭代。</p>
<h1 id="105"><a href="#105" class="headerlink" title="105"></a>105</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        return helper(0,0,inorder.length-1,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode helper(int preStart,int inStart, int inEnd, int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if(inStart&gt;inEnd || preStart &gt;= preorder.length) &#123;return null;&#125;</span><br><span class="line">        // root</span><br><span class="line">        TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(int i = index; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            if(inorder[i]==preorder[preStart]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = helper(preStart+1,inStart,index-1,preorder,inorder);</span><br><span class="line">        root.right = helper(preStart+index-inStart+1,index+1,inEnd,preorder,inorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难点在于计算右子树的preStart。因为题中给出的例子左子树只有一个节点，容易忽略考虑左子树的长度。</p>
<h1 id="106"><a href="#106" class="headerlink" title="106"></a>106</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        return helper(postorder.length-1,0,inorder.length-1,inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    public static TreeNode helper(int postEnd, int inStart, int inEnd, int[] inorder, int[] postorder) &#123;</span><br><span class="line">        if(postEnd&gt;=postorder.length || inStart&gt;inEnd) &#123;return null;&#125;</span><br><span class="line">        TreeNode root = new TreeNode(postorder[postEnd]);</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(int i = 0; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            if(inorder[i]==postorder[postEnd]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = helper(postEnd-inEnd+index-1,inStart,index-1,inorder,postorder);</span><br><span class="line">        root.right = helper(postEnd-1,index+1,inEnd,inorder,postorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难点在于计算左子树的preStart。因为题中给出的例子左子树只有一个节点，容易忽略考虑左子树的长度。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:日志</title>
    <url>/2020/01/23/MyBatis-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>如果一个数据库操作出现了异常，我们需要排错。日志就是最好的助手。<br>日志在核心配置文件中配置，使用标签<code>&lt;settings&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>name=&quot;logImpl&quot;</code>是固定的，表示日志的具体实现，value的值有SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</p>
<h1 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a>STDOUT_LOGGING</h1><p>标准化日志<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><p>通过Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等。<br>我们可以控制每一条日志的输出格式：通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。<br>这些可以通过一个配置文件来灵活地进行配置，而不需要修改里面的代码。</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h2><p>在应用的类路径中创建一个名为 log4j.properties 的文件，文件的具体内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/xliu.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure></p>
<h2 id="配置log4j为日志的实现"><a href="#配置log4j为日志的实现" class="headerlink" title="配置log4j为日志的实现"></a>配置log4j为日志的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol>
<li>导包<br> 在要使用Log4j的类中，导入包<code>import org.apache.log4j.Logger;</code></li>
<li>日志对象，参数为当前类的class<br><code>static Logger logger = Logger.getLogger(UserMapperTest.class);</code></li>
<li>日志级别<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.info(&quot;info:进入了testLog4j&quot;);</span><br><span class="line">logger.debug(&quot;debug:进入了testLog4J&quot;);</span><br><span class="line">logger.error(&quot;error:进入了testLog4J&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:分页</title>
    <url>/2020/04/08/MyBatis-%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="用Limit控制分页"><a href="#用Limit控制分页" class="headerlink" title="用Limit控制分页"></a>用Limit控制分页</h1><p>UserMapper.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void getUserByLimit() &#123;</span><br><span class="line">       SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">       map.put(&quot;startIndex&quot;,1);</span><br><span class="line">       map.put(&quot;pageSize&quot;,2);</span><br><span class="line">       List&lt;User&gt; userByLimit = mapper.getUserByLimit(map);</span><br><span class="line">       for (User user : userByLimit) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:模糊查询</title>
    <url>/2020/01/20/MyBatis-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>假设我们要查询一个名字里带“张”的用户，sql语句应该这样写：<code>select * from user where name like &#39;%张%&#39;</code>。<br>在MyBatis里有两种方法</p>
<h1 id="执行时传递通配符"><a href="#执行时传递通配符" class="headerlink" title="执行时传递通配符"></a>执行时传递通配符</h1><p>UserMapper.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加方法 --&gt;</span><br><span class="line">//    模糊查询</span><br><span class="line">    List&lt;User&gt; getUserLike(String value);</span><br></pre></td></tr></table></figure></p>
<p>UserMapper.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加标签 --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserLike&quot; resultType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        select * from mybatis.user where name like #&#123;value&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void getUserLike() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserLike(&quot;%张%&quot;);</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="在Sql拼接中使用通配符"><a href="#在Sql拼接中使用通配符" class="headerlink" title="在Sql拼接中使用通配符"></a>在Sql拼接中使用通配符</h1><p>UserMapper.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加方法 --&gt;</span><br><span class="line">//    模糊查询</span><br><span class="line">    List&lt;User&gt; getUserLike(String value);</span><br></pre></td></tr></table></figure></p>
<p>UserMapper.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加标签 --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserLike&quot; resultType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void getUserLike() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserLike(&quot;张&quot;);</span><br><span class="line">        for (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>两种方法的区别在于通配符”%”到底应该由用户传入(方法一)还是应该在xml中拼接，这样用户只需要输入“张”即可。第二种方法的优点是可以防止Sql注入。</p>
<h1 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h1><p>Sql注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<br>在第一种方法中，用户对于将要执行的sql语句有较高的自由度，因为我们将<code>select * from user where name like</code>之后的内容都交给用户来写，那么用户可能可以执行非法操作。如果我们使用第二种方法，用户只有权限去输入通配符中间的值，大大降低了Sql注入的风险。</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:生命周期和作用域</title>
    <url>/2020/01/22/MyBatis-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><img src="//xiaokeliu666.github.io/2020/01/22/MyBatis-生命周期和作用域/1.png" alt><br>上图为程序的执行顺序。配置文件config.xml创建SqlSessionFactoryBuilder,后者建造工厂SqlSessionFactory,工厂生产SqlSession，后者拿到Mapper（即Mapper.xml）。</p>
<p>生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<h1 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h1><ul>
<li>一旦创建了SqlSessionFactory，就不再需要它了</li>
<li>局部变量<h1 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h1></li>
<li>说白了就是可以想象为：数据库连接池</li>
<li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或者重新创建另一个实例</li>
<li>因此SqlSessionFactory的最佳作用域是应用作用域</li>
<li>最简单的就是单例模式或者静态单例模式<h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1></li>
<li>连接到连接池的一个请求</li>
<li>SqlSession的实例不是线程安全的，因此是不能共享大，所以它的最佳作用域是请求或方法作用域</li>
<li>用完之后需要赶紧关闭，否则资源被占用</li>
</ul>
<hr>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p><img src="//xiaokeliu666.github.io/2020/01/22/MyBatis-生命周期和作用域/2.png" alt></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:缓存</title>
    <url>/2020/04/11/MyBatis-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>什么是缓存？</p>
<ul>
<li>存在内存中的数据</li>
<li>将用户经常查询的数据存放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。<br>为什么使用缓存？</li>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率<br>什么样的数据能使用缓存？</li>
<li>经常查询并且不经常改变的数据<h1 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h1></li>
<li>MyBatis包含一个非常浅的嘎的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大地提升查询效率。</li>
<li>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。</li>
</ul>
</li>
</ul>
<h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间(从SqlSession创建到关闭)查询到的数据会放在本地缓存中</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li>启动日志</li>
<li>根据Id搜索用户</li>
<li>搜索同一个Id两次<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addInitBlog()&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    </span><br><span class="line">    User user1 = mapper.queryById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    System.out.println(&quot;==========&quot;);</span><br><span class="line">    User user2 = mapper.queryById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user1==user2);</span><br><span class="line">    </span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>日志输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Opening JDBC Connection</span><br><span class="line">Created connection 2088371948.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@7c7a06ec]</span><br><span class="line">==&gt;  Preparing: select * from user where id=? </span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">&lt;==    Columns: id, name, pwd</span><br><span class="line">&lt;==        Row: 1, xiaoke, 666</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">User&#123;id=1, name=&apos;xiaoke&apos;, pwd=&apos;666&apos;&#125;</span><br><span class="line">==========</span><br><span class="line">User&#123;id=1, name=&apos;xiaoke&apos;, pwd=&apos;666&apos;&#125;</span><br><span class="line">true</span><br><span class="line">Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@7c7a06ec]</span><br><span class="line">Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@7c7a06ec]</span><br><span class="line">Returned connection 2088371948 to pool.</span><br></pre></td></tr></table></figure></p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><ol>
<li>只执行了一次Sql语句</li>
<li>两个对象是相等的<h2 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h2></li>
<li>查询不同的东西</li>
<li>增删改操作，可能会改变数据库的内容，肯定会刷新缓存</li>
<li>查询不同的Mapper.xml</li>
<li>手动清理缓存(sqlSession.clearCache();)</li>
</ol>
<hr>
<p>一级缓存的实现就是一个Map，可以通过打断点来证明。</p>
<h1 id="缓存顺序"><a href="#缓存顺序" class="headerlink" title="缓存顺序"></a>缓存顺序</h1><ol>
<li>先看二级缓存中有没有</li>
<li>再看一级缓存中有没有</li>
<li>查询数据库</li>
</ol>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:动态SQL</title>
    <url>/2020/04/11/MyBatis-%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。<br>简而言之，动态SQL简化了SQL语句拼接</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table blog</span><br><span class="line">(</span><br><span class="line">    id          varchar(50)  not null comment &apos;博客id&apos;,</span><br><span class="line">    title       varchar(100) not null comment &apos;博客标题&apos;,</span><br><span class="line">    author      varchar(30)  not null comment &apos;博客作者&apos;,</span><br><span class="line">    create_time datetime     not null comment &apos;创建时间&apos;,</span><br><span class="line">    views       int(30)      not null comment &apos;浏览量&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>已经提前加入几条数据。</p>
<h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BlogMapper &#123;</span><br><span class="line">    // 根据条件查询博客</span><br><span class="line">    List&lt;Blog&gt; queryBlogIF(Map map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BlogMapper-xml"><a href="#BlogMapper-xml" class="headerlink" title="BlogMapper.xml"></a>BlogMapper.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">    select * from blog</span><br><span class="line">    where 1=1</span><br><span class="line">    &lt;if test=&quot;title!=null&quot;&gt;</span><br><span class="line">        and title =#&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author!=null&quot;&gt;</span><br><span class="line">        and author =#&#123;author&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>官方文档上写<code>where state=&#39;ACTIVATE&#39;</code>，但是在我的环境中会报错，用<code>where 1=1</code>替代是一样的效果，表示恒成立，即使if后面的语句不执行，也能查询出东西。<br>完整标签为<code>&lt;if test=&quot;判断条件&quot;&gt;&lt;/if&gt;</code></p>
<h1 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose(when,otherwise)"></a>choose(when,otherwise)</h1><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，<strong>它有点像 Java 中的 switch 语句。</strong></p>
<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BlogMapper &#123;</span><br><span class="line">    // 根据条件查询博客</span><br><span class="line">    List&lt;Blog&gt; queryBlogChoose(Map map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BlogMapper-xml-1"><a href="#BlogMapper-xml-1" class="headerlink" title="BlogMapper.xml"></a>BlogMapper.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">        select * from blog</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;choose&gt;</span><br><span class="line">                &lt;when test=&quot;title!=null&quot;&gt;</span><br><span class="line">                    title=#&#123;title&#125;</span><br><span class="line">                &lt;/when&gt;</span><br><span class="line"></span><br><span class="line">                &lt;when test=&quot;author!=null&quot;&gt;</span><br><span class="line">                    and author=#&#123;author&#125;</span><br><span class="line">                &lt;/when&gt;</span><br><span class="line"></span><br><span class="line">                &lt;otherwise&gt;</span><br><span class="line">                    and views=#&#123;views&#125;</span><br><span class="line">                &lt;/otherwise&gt;</span><br><span class="line">            &lt;/choose&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>注意：此处使用\<where>标签替代了上一个例子中的<code>where 1=1</code>语句，相比后者，前者更优雅地实现了智能拼接。在此例中，如果”title!=null”不成立且”author!=null”成立，在最后拼接时\<where>标签可以识别出<code>where and author=#{author}</code>这样的错误语句并去掉and。</where></where></p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><h2 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BlogMapper &#123;</span><br><span class="line">    int updateBlog(Map map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BlogMapper-xml-2"><a href="#BlogMapper-xml-2" class="headerlink" title="BlogMapper.xml"></a>BlogMapper.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">    update blog</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;title!=null&quot;&gt;</span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;author!=null&quot;&gt;</span><br><span class="line">            author =#&#123;author&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<p>在使用update语句时容易出现的拼接问题是逗号后面紧跟一个where，例如此例中可能会出现<code>update blog set author=#{author}, where id=#{id}</code>的情况，因此\<set>标签也和\<where>标签一样可以智能地识别多余的逗号并去除。</where></set></p>
<h1 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h1><p>我们可以用\<sql>标签把上述三个例子中都出现的SQL片段抽取出来<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;if-title-author&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;title!=null&quot;&gt;</span><br><span class="line">        title = #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author!=null&quot;&gt;</span><br><span class="line">        and author =#&#123;author&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure></sql></p>
<p>需要使用的时候:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;if-title-author&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>即可实现代码的复用。<br>注意事项：</p>
<ul>
<li>最好基于单表来定义SQL片段</li>
<li>不要存在where标签</li>
</ul>
<h1 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h1><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。<br>假设现在需要查询id为1，2，3的三条数据，SQL语句为<code>select * from blog where 1=1 and (id=1 or id=2 or id=3)</code></p>
<h2 id="使用foreach标签"><a href="#使用foreach标签" class="headerlink" title="使用foreach标签"></a>使用foreach标签</h2><h3 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BlogMapper &#123;</span><br><span class="line">    List&lt;Blog&gt; queryBlogForeach(Map map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BlogMapper-xml-3"><a href="#BlogMapper-xml-3" class="headerlink" title="BlogMapper.xml"></a>BlogMapper.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">        select * from blog</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>foreach标签中collection是集合，item是集合中的对象（很类似于java中的<code>for(:)</code>语句），open是开头，seperator是分隔符，close是结尾。以这样的方式来拼接SQL语句。<br>此例中最终拼接成的语句为：<code>select * from blog where 1=1 and (id=1 or id=2 or id=3)</code></p>
<h3 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    Map map = new HashMap();</span><br><span class="line">    ArrayList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    ids.add(1);</span><br><span class="line">    ids.add(2);</span><br><span class="line">    ids.add(3);</span><br><span class="line">    map.put(&quot;ids&quot;,ids);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);</span><br><span class="line">    for (Blog blog : blogs) &#123;</span><br><span class="line">        System.out.println(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:工具类</title>
    <url>/2020/01/19/MyBatis%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。<br>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但是也可以使用任意的输入流（InputStream）实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>
<p>以上内容来自<a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">MyBatis官方文档</a></p>
<p>简而言之就是再用MyBatis框架连接数据库时，需要创建SqlSessionFactory。因此为了避免编写重复代码，通常将这一步骤封装成一个工具类。以下是我写的工具类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 首先用一个专门的utils包来装工具类</span><br><span class="line">    package com.xliu.utils;</span><br><span class="line"></span><br><span class="line">    import org.apache.ibatis.io.Resources;</span><br><span class="line">    import org.apache.ibatis.session.SqlSession;</span><br><span class="line">    import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">    import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line">    import java.io.IOException;</span><br><span class="line">    import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">    public class MybatisUtil &#123;</span><br><span class="line">        private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 官方文档上的代码，要注意配置文件的路径</span><br><span class="line">                String resource = &quot;config.xml&quot;;</span><br><span class="line">                InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                sqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 以上步骤帮助我们创建了sqlSessionFactory,以下方法获得SqlSession的实例。</span><br><span class="line">        public static SqlSession getSqlSession() &#123;</span><br><span class="line">            return sqlSessionFactory.openSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>SqlSession完全包含了面向数据库执行SQL命令所需的所有方法。可以通过SqlSession实例来直接执行已映射的SQL语句。</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:注解开发</title>
    <url>/2020/04/08/MyBatis-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>使用注解开发可以完全省略掉<code>XXXMapper.xml</code>文件<br>UserMapper(接口)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">@Select(&quot;select * from user&quot;)</span><br><span class="line">List&lt;User&gt; getUser();</span><br><span class="line"></span><br><span class="line">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br><span class="line">User getUserById(@Param(&quot;id&quot;) int id);</span><br><span class="line"></span><br><span class="line">// 与实体类属性保持一致，虽然数据库里的字段是pwd，但是实体类中是password所以#&#123;password&#125;</span><br><span class="line">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span><br><span class="line">int addUser(User user);</span><br><span class="line"></span><br><span class="line">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">int updateUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserMapperTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void getUserTest() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; user = mapper.getUser();</span><br><span class="line">        for (User user1 : user) &#123;</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void getUserByIdTest() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User userById = mapper.getUserById(1);</span><br><span class="line">        System.out.println(userById);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void addUserTest() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(new User(5,&quot;leo&quot;,&quot;666&quot;));</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void updateTest() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.updateUser(new User(1,&quot;xiaoke&quot;,&quot;666&quot;));</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解开发的底层实现是应用反射。<br>但是这个例子中有个问题，实体类中是password但是数据库字段为pwd，获取数据时，pwd会为null，所以官网上说注解开发只适用于简单场景，如果场景复杂还是建议xml</p>
<h1 id="与-的区别"><a href="#与-的区别" class="headerlink" title="#与$的区别"></a>#与$的区别</h1><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符?:</p>
<p>对于 : INSERT INTO user (name) VALUES (#{name}); ==&gt; INSERT INTO user (name) VALUES (?);</p>
<p>${} 符号的作用是直接进行字符串替换:</p>
<p>对于 : INSERT INTO user (name) VALUES (‘${name}’); ==&gt; INSERT INTO user (name) VALUES (‘tianshozhi’);</p>
<p>为了防止SQL注入，建议使用#{}.</p>
<h1 id="关于-Param-注解"><a href="#关于-Param-注解" class="headerlink" title="关于@Param()注解"></a>关于@Param()注解</h1><ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上</li>
<li>我们在SQL中引用的就是我们这里@Param()中设定的属性名<br>例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br><span class="line">User getUserById(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果吧@Param改成(“id2”),上面的#{}也要改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Select(&quot;select * from user where id = #&#123;id2&#125;&quot;)</span><br><span class="line">User getUserById(@Param(&quot;id2&quot;) int id);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:执行SQL语句</title>
    <url>/2020/01/19/MyBatis%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>我们已经完成工具类的设计，即从SqlSessionFactory中获取SqlSession，那么如何使用SqlSession来执行Sql语句呢？<br>假设我们现在已经有一张User表，并且里面存了一些信息，现在我想对这张表执行CRUD</p>
<h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>传统方法中我们需要建立一个Dao包，在Dao包里面有接口以及接口实现类，每增加一个新的接口方法就需要新增一个实现类，实现类类里的方法就是对数据库的操作，增删改查之类的。</p>
<h1 id="Mapper代理方法"><a href="#Mapper代理方法" class="headerlink" title="Mapper代理方法"></a>Mapper代理方法</h1><p>在这种方法中，接口类中每增加一个方法，只需要在xml中新增一个标签。<br>UserMapper.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    package com.xliu.dao;</span><br><span class="line"></span><br><span class="line">&lt;!-- User的实体类 --&gt;</span><br><span class="line">    import com.xliu.pojo.User;</span><br><span class="line"></span><br><span class="line">    import java.util.List;</span><br><span class="line"></span><br><span class="line">    public interface UserMapper &#123;</span><br><span class="line">        &lt;!-- 定义一个抽象方法getUser()，返回类型是一个User类型的List --&gt;</span><br><span class="line">        List&lt;User&gt; getUser();</span><br><span class="line">        //    根据Id查询用户</span><br><span class="line">        User getUserById(int id);</span><br><span class="line"></span><br><span class="line">        void addUser(User user);</span><br><span class="line"></span><br><span class="line">        void updateUser(User user);</span><br><span class="line"></span><br><span class="line">        void deleteUser(int id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>UserMapper.xml：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.xliu.dao.UserMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUser&quot; resultType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;com.xliu.pojo.User&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from mybatis.user where id=#&#123;id&#125;;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p>
<p>UserMapper.xml文件中，namespace对应接口，select id对应接口(namespace)中的方法名，resultType对应Sql语句执行的返回类型，如果接口方法有输入值的话，则添加属性parameterType。<br>另外需要注意的是增删改查的SQL语句对应的标签是不同的。</p>
<p>另外一定要记住，在/resources/config.xml中要添加Mapper.xml的映射：<br>config.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">    &lt;!DOCTYPE configuration</span><br><span class="line">            PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">            &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">            &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">                &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">                &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;password&quot; value=&quot;pwd&quot;/&gt;</span><br><span class="line">                &lt;/dataSource&gt;</span><br><span class="line">            &lt;/environment&gt;</span><br><span class="line">        &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加Mapper.xml的映射 --&gt;</span><br><span class="line">        &lt;mappers&gt;</span><br><span class="line">            &lt;mapper resource=&quot;com/xliu/dao/UserMapper.xml&quot;/&gt;</span><br><span class="line">        &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.dao;</span><br><span class="line"></span><br><span class="line">import com.xliu.pojo.User;</span><br><span class="line">import com.xliu.utils.MybatisUtil;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class UserMapperTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">            List&lt;User&gt; userList = mapper.getUser();</span><br><span class="line">            for (User user : userList) &#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testById() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User userById = mapper.getUserById(1);</span><br><span class="line">        System.out.println(userById);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void addUser() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(new User(4,&quot;hha&quot;, &quot;pwd&quot;));</span><br><span class="line"></span><br><span class="line">//        增删改需要提交事务</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void updateUser() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.updateUser(new User(2,&quot;Liu&quot;,&quot;password&quot;));</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void deleteUser() &#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.deleteUser(4);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要记住：执行完一次之后需要<code>sqlSession.close()</code>，增删改的语句需要提交事务<code>sqlSession.commit()</code></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:collection</title>
    <url>/2020/04/11/MyBatis-collection/</url>
    <content><![CDATA[<p>和association一样，collection用于处理复杂关系。不同的是association用于映射单个对象，而collection用于映射集合对象。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>创建student表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">     `id` INT(10) NOT NULL,</span><br><span class="line">     `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">     `tid` INT(10) DEFAULT NULL,</span><br><span class="line">     PRIMARY KEY (`id`),</span><br><span class="line">     KEY `fktid` (`tid`),</span><br><span class="line">     CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)</span><br><span class="line">     ) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p>
<p>创建teacher表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">     `id` INT(10) NOT NULL,</span><br><span class="line">     `name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">     PRIMARY KEY (`id`)</span><br><span class="line">     )ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure></p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>根据teacher的id查出老师手下的所有学生</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select t.name tname, s.id sid, s.name sname</span><br><span class="line">from teacher t, student s</span><br><span class="line">where t.id=s.tid and t.id=#&#123;tid&#125;</span><br></pre></td></tr></table></figure>
<h1 id="MyBatis实现"><a href="#MyBatis实现" class="headerlink" title="MyBatis实现"></a>MyBatis实现</h1><h2 id="实体类-pojo"><a href="#实体类-pojo" class="headerlink" title="实体类(pojo)"></a>实体类(pojo)</h2><p>Student.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int tid;</span><br><span class="line">    &lt;!-- getter,setter,toString --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Teacher.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Student&gt; students;</span><br><span class="line">    &lt;!-- getter,setter,toString --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与association的要求不同，此处的要求是根据老师的id属性去查询学生，因此构建实体类时也需要变化。</p>
<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>用了@Param(“tid”)后，xml中的输入也要注意用tid，xml中会进一步解释。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TeacherMapper &#123;</span><br><span class="line">    Teacher getTeacher(@Param(&quot;tid&quot;) int id);</span><br><span class="line">    Teacher getTeacher2(@Param(&quot;tid&quot;) int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="TeacherMapper-xml"><a href="#TeacherMapper-xml" class="headerlink" title="TeacherMapper.xml"></a>TeacherMapper.xml</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>先根据输入的id查询老师，然后从根据tid查询出学生<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot; &gt;</span><br><span class="line">&lt;!-- id=#&#123;tid&#125;意为接受参数 --&gt;</span><br><span class="line">    select * from teacher where id=#&#123;tid&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;</span><br><span class="line">    &lt;collection property=&quot;students&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherID&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getStudentByTeacherID&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">    select * from student where tid=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p>
<p>此方法需要注意的是collection标签中的column对应的是Teacher类中的id属性（注意resultMap的type是Teacher），javaType应该写ArrayList，因为student属性是一个集合，ofType用于获取集合中的泛型。</p>
<h3 id="结果集嵌套查询"><a href="#结果集嵌套查询" class="headerlink" title="结果集嵌套查询"></a>结果集嵌套查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;</span><br><span class="line">    select t.name tname, s.id sid, s.name sname</span><br><span class="line">    from teacher t, student s</span><br><span class="line">    &lt;!-- id=#&#123;tid&#125;意为接受参数 --&gt;</span><br><span class="line">    where t.id=s.tid and t.id=#&#123;tid&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;</span><br><span class="line">    &lt;!-- 集合中泛型的信息，用ofType获取 --&gt;</span><br><span class="line">    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;</span><br><span class="line">        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>同association，先查询出结果，然后再用resultMap进行说明。</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:使用Map参数类型</title>
    <url>/2020/01/20/MyBatis%E4%BD%BF%E7%94%A8Map%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>上一篇文章中介绍了简单的CRUD语句，其中当我们需要根据Id更新name以及pwd字段时，传入的实际上是一个对象：<br>测试类中的方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapper.updateUser(new User(2,&quot;Liu&quot;,&quot;password&quot;));</span><br></pre></td></tr></table></figure></p>
<p>UserMapper.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">    update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></p>
<p>想象一下当数据库的字段变得非常多的时候，假设一个用户同时拥有id,name,pwd,address,hobby,phone等多条属性时，再做上述操作传入对象时，我们需要填写所有的字段的值，即使我们的需求仅仅是根据id改用户的密码。<br>为了解决上述问题，我们可以使用Map作为参数的类型</p>
<h1 id="使用Map参数"><a href="#使用Map参数" class="headerlink" title="使用Map参数"></a>使用Map参数</h1><p>已知Map是一个<key,value>的数据结构，我们可以将我们所需要用到的字段以及值存储进去，包括条件字段以及需要更新的字段。<br>回归上述情形，假设一条用户数据有很多个字段，而现在的需求是根据用户ID更改用户密码，因此我们只需要将这两个字段以及值存入Map中。<br>UserMapper.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加一条方法 --&gt;</span><br><span class="line">    void updateUser2(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure></key,value></p>
<p>UserMapper.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加一个标签 --&gt;</span><br><span class="line">    &lt;update id=&quot;updateUser2&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">        update mybatis.user set pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;</span><br><span class="line">    &lt;/update&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void updateUser2() &#123;</span><br><span class="line">       </span><br><span class="line">       SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       &lt;!-- 创建一个HashMap对象 --&gt;</span><br><span class="line">       HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">       &lt;!-- 添加K-V数据 --&gt;</span><br><span class="line">       map.put(&quot;id&quot;, 1);</span><br><span class="line">       map.put(&quot;pwd&quot;, &quot;password&quot;);</span><br><span class="line">       &lt;!-- 将map作为参数传入方法 --&gt;</span><br><span class="line">       mapper.updateUser2(map);</span><br><span class="line">       sqlSession.commit();</span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Map传递参数，设置parameterType=”map”后，直接在sql中取出key即可：<code>update mybatis.user set pwd=#{pwd} where id=#{id};</code>。另外，此处#{}中可以用任意的名字，只要在创建map的时候和Key的名字统一就行。</p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy Pattern</title>
    <url>/2020/01/08/Proxy-Pattern/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>A real world example can be a cheque or credit card is a proxy for what is in our bank account. It can be used in place of cash, and provides a means of accessing that cash when required. And that’s exactly what the proxy pattern does – <strong>“Controls and manage access to the object they are protecting”.</strong></p>
<p>Another example in real life, when we want to book a flight, we sometimes will refer to a thrid party like Tripadvisor other than airline.<br>In this example, the Tripadvisor is a proxy. Using tripadvisor, we can avoid directly contacting with airline because tripadvisor can sell tickets on behalf of airline. However, different from airline, Tripadvisor may also provide some other service that airline doesn’t have such as hotel coupon.</p>
<h1 id="Code-Example"><a href="#Code-Example" class="headerlink" title="Code Example"></a>Code Example</h1><p>UserService.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.demo02;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    public void add();</span><br><span class="line">    public void delete();</span><br><span class="line">    public void update();</span><br><span class="line">    public void query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Define a interface that include several database operations.</p>
<p>UserServiceImpl.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.demo02;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    public void add() &#123; System.out.println(&quot;Add a user&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123; System.out.println(&quot;Delete a user&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123; System.out.println(&quot;Update a user&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123; System.out.println(&quot;Query a user&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Implement the interface.</p>
<p>UserServiceProxy.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.demo02;</span><br><span class="line"></span><br><span class="line">public class UserService Proxy implements UserService &#123;</span><br><span class="line">    UserImpl user = new UserImpl();</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        log(&quot;add&quot;);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        log(&quot;delete&quot;);</span><br><span class="line">        user.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        log(&quot;update&quot;);</span><br><span class="line">        user.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        log(&quot;query&quot;);</span><br><span class="line">        user.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;Use&quot; +msg+ &quot;method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Design a proxy.</p>
<p>Client:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Using the <code>add()</code> method at Client without interacting with <code>UserServiceImpl</code> but <code>Proxy</code> </p>
<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Using compositing to call a object of User.</p>
<p>Those methods need to be rewrite in proxy class but using the User object to call instead of repeating the same method body.</p>
<p>In this example I showed that a proxy can not only provide an interface of original method to client, but also do some modification (like adding a log in this example).</p>
<h1 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h1><ul>
<li>One of the advantages of Proxy pattern is security.</li>
<li>This pattern avoids duplication of objects which might be huge size and memory intensive. This in turn increases the performance of the application.</li>
</ul>
<h1 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h1><p>This pattern introduces another layer of abstraction which sometimes may be an issue if the RealSubject code is accessed by some of the clients directly and some of them might access the Proxy classes. This might cause disparate behaviour.</p>
]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL笔记：基础</title>
    <url>/2020/03/25/MySQL%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="SHOW"><a href="#SHOW" class="headerlink" title="SHOW"></a>SHOW</h4><p>输入：<br> <code>SHOW COLUMNS FROM customers;</code><br> <code>DESCRIBE customers;</code><br>输出：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Field</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra          </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>cust_id</td>
<td>int(11)</td>
<td>NO</td>
<td>PRI</td>
<td>NULL</td>
<td>auto_increment </td>
</tr>
<tr>
<td></td>
<td>cust_name</td>
<td>char(50)</td>
<td>NO</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_address</td>
<td>char(50)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_city</td>
<td>char(50)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_state</td>
<td>char(5)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_zip</td>
<td>char(10)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_country</td>
<td>char(50)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_contact</td>
<td>char(50)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cust_email</td>
<td>char(255)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><code>SHOW COLUMNS</code> 返回表的信息，包括字段名、数据类型等，与<code>DESCRIBE</code>等价。</p>
<ul>
<li><code>SHOW STATUS</code>：显示广泛的服务器状态信息；</li>
<li><code>SHOW CREATE DATABSE</code>,<code>SHOW CREATE TABLE</code>：显示创建特定数据库或表的MySQL语句</li>
<li><code>SHOW GRANTS</code>：显示授予用户（所有用户或特定用户）的安全权限</li>
<li><code>SHOW ERRORS</code>,<code>SHOW WARNINGS</code>：显示服务器错误或警告消息<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><code>SELECT prod_name FROM products;</code>：products表中名为prod_name的列<br><code>SELECT prod_id,prod_name,prod_price FROM products;</code>：products表中指定的3列<br><code>SELECT * FROM products;</code>：通配符(*)返回表中所有列<br><code>SELECT DISTINCT vend_id FROM products;</code>：<code>DISTINCT</code>只返回不同的值，如果<code>ven_id</code>中有重复的会被省略<br><code>SELECT prod_name FROM products LIMIT 5;</code>：<code>LIMIT 5</code>指示返回不多于5行<br><code>SELECT prod_name FROM products LIMIT 5,3;</code>：从第5行开始再输出3行<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><code>SELECT prod_name FROM products ORDER BY prod_name;</code>：对prod_name列以字母顺序排序<br><code>SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price, prod_name;</code>：当多个行具有相同的prod_price值时才对产品按prod_name进行排序。<br><code>SELECT prod+id, prod_price, prod_name FROM products ORDER BY prod_price DESC</code>：<code>DESC</code>指定prod_price降序排序<br><code>SELECT prod+id, prod_price, prod_name FROM products ORDER BY prod_price DESC</code></li>
</ul>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis+Mysql实现有则更新，无则插入</title>
    <url>/2020/05/13/Mybatis-Mysql%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%88%99%E6%9B%B4%E6%96%B0%EF%BC%8C%E6%97%A0%E5%88%99%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<h1 id="MySQL实现"><a href="#MySQL实现" class="headerlink" title="MySQL实现"></a>MySQL实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into books (`bookName`,`bookCounts`,`detail`) </span><br><span class="line">values (&apos;MySQL&apos;,5,&apos;快跑辣&apos;) </span><br><span class="line">on duplicate key update `bookCounts`=`bookCounts`+values(`bookCounts`),`detail` = values(`detail`);</span><br></pre></td></tr></table></figure>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;</span><br><span class="line">    insert into books (bookName,bookCounts,detail)</span><br><span class="line">    values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;)</span><br><span class="line">    on duplicate key update bookCounts=bookCounts+values(#&#123;bookCounts&#125;), detail=values(#&#123;detail&#125;) ;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<p>日志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: insert into books (bookName,bookCounts,detail) values (?,?,?) on duplicate key update bookCounts=bookCounts+values(?), detail=values(?) ; </span><br><span class="line">==&gt; Parameters: MySQL(String), 2(Integer), 2(String), 2(Integer), 2(String)</span><br></pre></td></tr></table></figure></p>
<h1 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;</span><br><span class="line">    insert into books (bookName,bookCounts,detail)</span><br><span class="line">    values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;)</span><br><span class="line">    // 下面不用#&#123;&#125;取数值</span><br><span class="line">    on duplicate key update bookCounts=bookCounts+values(bookCounts), detail=values(detail) ;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<p>日志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: insert into books (bookName,bookCounts,detail) values (?,?,?) on duplicate key update bookCounts=bookCounts+values(bookCounts), detail=values(detail) ; </span><br><span class="line">==&gt; Parameters: MySQL(String), 2(Integer), 2(String)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
        <tag>MySQL</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis:映射器</title>
    <url>/2020/01/22/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<p>在定义SQL映射语句之前，我们需要告诉MyBatis到哪里去找到这些语句，因此我们需要在配置文件中告诉MyBatis到哪里去寻找映射文件。可以使用相对于类路径的资源引用，或完全限定资源定位符（包括file:///的URL），或类名和包名。<br>已知目录中，com.xliu.dao包中有：接口UserMapper, UserMapper.xml; 配置文件config.xml在resources目录下。</p>
<h1 id="使用相对于类路径的资源引用（推荐）"><a href="#使用相对于类路径的资源引用（推荐）" class="headerlink" title="使用相对于类路径的资源引用（推荐）"></a>使用相对于类路径的资源引用（推荐）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;com/xliu/dao/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<p>每一个Mapper.xml都需要在Mybatis核心配置文件中注册！</p>
<h1 id="使用完全限定资源定位符（URL）"><a href="#使用完全限定资源定位符（URL）" class="headerlink" title="使用完全限定资源定位符（URL）"></a>使用完全限定资源定位符（URL）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper class=&quot;com.xliu.dao.UserMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>接口和Mapper配置文件必须同名</li>
<li>接口和Mapper配置文件必须在同一包下<h1 id="将包内的映射器接口是选全部注册为映射器"><a href="#将包内的映射器接口是选全部注册为映射器" class="headerlink" title="将包内的映射器接口是选全部注册为映射器"></a>将包内的映射器接口是选全部注册为映射器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;package name=&quot;com.xliu.dao&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意点：</p>
<ul>
<li>接口和Mapper配置文件必须同名</li>
<li>接口和Mapper配置文件必须在同一包下</li>
</ul>
<hr>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>如果SQL语句写在XML文件里，则使用<code>&lt;mapper resource=&quot;com/xliu/dao/UserMapper.xml&quot;/&gt;</code>，如果是用注解实现，例如TeacherMapper.java(接口):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TeacherMapper &#123;</span><br><span class="line">    @Select(&quot;select * from teacher where id=#&#123;tid&#125;&quot;)</span><br><span class="line">    Teacher getTeacher(@Param(&quot;tid&quot;) int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么使用<code>&lt;mapper class=&quot;com.xliu.dao.TeacherMapper&quot;/&gt;</code></p>
]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python踩坑：Pycharm中使用Pytorch</title>
    <url>/2019/09/16/Python%E8%B8%A9%E5%9D%91%EF%BC%9APycharm%E4%B8%AD%E4%BD%BF%E7%94%A8Pytorch/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>尝试使用<code>pip install pytorch</code>指令在pycharm中使用Pytorch框架失败</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>在anaconda中使用<code>conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</code>指令安装pytorch后，再在Pycharm中创建新project的时候使用anaconda的环境即可</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>最近Anaconda官网上好像只能下载到3.7版本的了，所以在此之前我创建了一个版本为3.6的虚拟环境(py36)，因此在创建project时导入anaconda的环境需要导入虚拟环境目录下的python文件（D:\Anaconda3\envs\py36\python.exe）</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot学习笔记(一)</title>
    <url>/2020/01/19/Spring-Boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><ol>
<li>新建一个Module-&gt;Spring Initializr</li>
<li>Dependencies: Spring Web, JDBC API, MyBatis Framework, MySQL Driver</li>
<li><code>pom.xml</code> 文件中已经把依赖配置好了</li>
</ol>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>application.properties<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=8080  // 服务端口</span><br><span class="line"></span><br><span class="line"># jdbc</span><br><span class="line">spring.datasource.password=pwd // 数据库密码</span><br><span class="line">spring.datasource.username=root // 数据库用户</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/gmall_study?characterEncoding=UTF-8&amp;serverTimezone=GMT-5 // 数据库url记得要在3306后面写数据库的名字，serverTimezone也要手动设置，不然可能会报错</span><br><span class="line"></span><br><span class="line"># mybatis</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*Mapper.xml  // 读取mapper目录下所有以Mapper.xml结尾的文件，即映射器文件的位置</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true // MySQL一般定义字段用下划线表示，该配置项就是指将带有下划线的表字段映射为驼峰格式的实体类属性</span><br></pre></td></tr></table></figure></p>
<h1 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h1><p>controller层负责具体的业务模块流程的控制，在此层要调用service层的接口实现业务逻辑</p>
<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>服务是一个相对独立的功能模块，主要负责业务逻辑应用设计。首先也要设计接口，然后再设计其实现该接口的类。这样我们就可以在应用中调用service接口进行业务处理。service层业务实现，具体调用到已经定义的Mapper的接口，封装service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性 。</p>
<h1 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h1><p>通常我们在mapper层里面写接口，里面有与数据打交道的方法。SQL语句通常写在mapper文件里面的</p>
<h1 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h1><p>bean实体类，映射数据库中的表，里面有表的属性以及get/set方法</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Note 0: IOC</title>
    <url>/2019/12/30/Spring-Note-0-IOC/</url>
    <content><![CDATA[<blockquote>
<p>Spring makes programming Java quicker, easier, and safer for everybody. </p>
</blockquote>
<p>以上这句话引用自Spring官网，用于回答问题”Why Spring?”， Spring提高编程效率的一个主要原因就是IOC（Inversion of Control），那么在了解IOC之前需要先了解传统的三层架构。</p>
<h1 id="使用IOC之前"><a href="#使用IOC之前" class="headerlink" title="使用IOC之前"></a>使用IOC之前</h1><p>根据我目前的理解，三层架构即为dao层，service层，controller层。在此举个例子介绍。</p>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><p>接口UserDao:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    void getUser();  // 获取用户的方法，待实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类UserDaoImpl:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;获取用户信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类UserDaoMysqlImpl:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoMysqlImpl implements UserDao&#123;</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        System.out.println(&quot;Mysql获取用户信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以此类推可以有很多种实现的方式。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>因为目前对service层的理解不够深，所以关于Service层的作用，网上搜集到以下说法：</p>
<ol>
<li>粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务</li>
<li>dao层用与和底层的数据库打交道，因此只要是不和数据库打交道的都放在service层</li>
</ol>
<p>接口类UserService:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    void getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类UserServiceImpl:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    UserDao userDao = new UserDaoMysqlImpl();</span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>本来应该是Controller类的，但是这里暂时用测试类。<br>MyTest:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserServiceImpl userService=new UserServiceImpl();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mysql获取用户信息</span><br></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以上方法应该是最初级三层架构的方法：流程大概是用户只需要调用服务层中的类，服务层再去调用底层的dao。</p>
<p>假设现在需要添加需求：Oracle获取用户信息。我需要做以下操作：1. Dao层添加新的实现UserDaoOracleImpl; 2.Service层实现类中创建的实体要改成 new UserOracleImpl()以调用Dao层的Oracle实现；</p>
<p>在此方法中创建对象的控制权在Service层中。</p>
<hr>
<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>Dao层不变，Service层中加入Set方法</p>
<h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><p>实现类ServiceImpl:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getUser() &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><p>MyTest:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">        userService.setUserDao(new UserDaoMysqlImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mysql获取用户信息</span><br></pre></td></tr></table></figure></p>
<h1 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h1><p>三层架构的调用顺序不变，但是在service层中引入set方法，那么将具体使用哪一个dao的实现类的控制权交付到了用户端。在IOC之前，这个控制权相当于写死在Service层中，我们希望尽可能少地更改底层的代码，使用IOC后，我们只需要在MyTest中通过改变setUserDao的参数即可改变实现的方法。</p>
<hr>
<h1 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h1><p>控制反转IOC本质是一种设计思想，依赖注入DI是一种实现的方法，没有IOC的程序中，我们使用面向对象编程，对象的创建与对象之间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。</p>
<p>在Spring中实现控制反转的IOC容器，其实现方式是依赖注入。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Note：SYSC5105</title>
    <url>/2019/10/06/Note%EF%BC%9ASYSC5105/</url>
    <content><![CDATA[<p><strong>Three conditions necessary to observe the failure</strong><br><strong>Reachability</strong>: The location(s) in the program that contain fault must be reached<br><strong>Infection</strong>: The state of the program must be incorrect<br><strong>Propagation</strong>: The infected state must be propagated to cause some unexpected result/output</p>
<p><strong>Observability</strong>: How easy to observe the behavior of a program in terms of the outputs, effect on the environment including hardware and software components<br><strong>Controllability</strong>: How easy it is to proveid a program with the needed inputs</p>
<p><strong>Test driver</strong>: executes a test case or a test suite/set<br><strong>Stub</strong>: replaces a called component, simulates a piece of code not yet ready<br><strong>Oracle</strong>: assists in deciding whether a test outcome is successful or not, comparing the actual output against expected output; deciding what output is expected, given the test inputs of a test case</p>
<p><strong>Tech to reduce the number of inputs</strong>:<br>Testing criteria group input elements into classes<br>One input is selected in each class<br>Criteria are used to decide which test inputs to use<br>Criteria are used to decide when to stop testing</p>
<p><strong>Black box</strong>:<br>Scales up - works for a function/class/system/packet<br>Don’t know how much of the system is being tested<br><strong>White box</strong>:<br>Based on control and data flow<br>Not Scales up - mostly applicable at unit and integration testing levels<br>Be confident about how much of the system is being tested</p>
<p><strong>Selection criterion</strong>:<br>generate values to satisfy the criterion<br><strong>Coverage criterion</strong>:<br>Evaluate coverage achieved by externally generated test values/ cases</p>
<p><strong>Verification</strong>:<br>The process of evaluating a system or component to determine whether the products of a given development phase satisfies the conditions imposed at the start of that phase.<br>Checking whether the system adheres to properties termed as verification properties<br><strong>Validation</strong>:<br>The process of evaluating a system or component during or at the end of the development process to determine whether it satisfies specified requirements.</p>
<p><strong>Fault</strong>: a deficit in a system<br><strong>Error</strong>: some part of the system entered an unexpected state<br><strong>Failure</strong>: the delivered service deviated from what the system is intended for</p>
]]></content>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 2: Autowire</title>
    <url>/2020/01/04/Spring-Note-2-Autowire/</url>
    <content><![CDATA[<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. </p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>Dog.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">    public void shout() &#123;</span><br><span class="line">        System.out.println(&quot;wang&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Cat.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    public void shout() &#123;</span><br><span class="line">        System.out.println(&quot;miao&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>People.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class People &#123;</span><br><span class="line">    private Cat cat;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;People&#123;&quot; +</span><br><span class="line">                &quot;cat=&quot; + cat +</span><br><span class="line">                &quot;, dog=&quot; + dog +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Cat getCat() &#123;return cat;&#125;</span><br><span class="line"></span><br><span class="line">    public void setCat(Cat cat) &#123;this.cat = cat;&#125;</span><br><span class="line"></span><br><span class="line">    public Dog getDog() &#123;return dog;&#125;</span><br><span class="line"></span><br><span class="line">    public void setDog(Dog dog) &#123;this.dog = dog;&#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;return name;&#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;this.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Before-autowired"><a href="#Before-autowired" class="headerlink" title="Before autowired"></a>Before autowired</h1><p>Beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.xliu.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.xliu.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;com.xliu.pojo.People&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="After-autowired"><a href="#After-autowired" class="headerlink" title="After autowired"></a>After autowired</h1><p>Beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.xliu.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.xliu.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;com.xliu.pojo.People&quot; autowire=&quot;byName&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>OR</p>
<p>Beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.xliu.pojo.Cat&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.xliu.pojo.Dog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;people&quot; class=&quot;com.xliu.pojo.People&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>Noticed that both codes omit the <code>ref=&quot;&quot;</code>, because using autowire enable spring to automatically search in the context and match the property.</p>
<h1 id="byName-amp-byType"><a href="#byName-amp-byType" class="headerlink" title="byName &amp; byType"></a>byName &amp; byType</h1><p>autowire has two value: byName, byType.</p>
<ul>
<li><p>byName: automatically search in context and match the suffix of <code>setXXX</code> of object with corresponding beanid.</p>
<p>For example, class people has method <code>setDog()</code> and there is a <code>bean id =&quot;dog&quot;</code>, they will match. If we change the id to dog222, then they won’t match and error occurs.</p>
</li>
<li><p>byType: automatically search in context and match the class of object with corresponding beanclass. If using byType, we can even skip define bean id because only class is used to match.</p>
<p>  The disadvantage of byType is we can’t register two beans refer to the same class.</p>
</li>
</ul>
<hr>
<h1 id="Using-annotaion"><a href="#Using-annotaion" class="headerlink" title="Using annotaion"></a>Using annotaion</h1><p>Place <code>@Autowired</code> before the attribute in pojo, for example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Cat cat;</span><br><span class="line">@Autowired</span><br><span class="line">private Dog dog;</span><br></pre></td></tr></table></figure></p>
<p>Turn on the support for annotaion in xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure></p>
<p>With such configuration, many lines can be omitted, we only need:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;people&quot; class=&quot;com.xliu.pojo.People&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>So, this method is based on byType</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 3</title>
    <url>/2020/03/28/Spring-Note-3/</url>
    <content><![CDATA[<h1 id="UserDao-userdao-new-UserDaoImpl"><a href="#UserDao-userdao-new-UserDaoImpl" class="headerlink" title="UserDao userdao = new UserDaoImpl();"></a>UserDao userdao = new UserDaoImpl();</h1><p>UserDao is an interface class, UserDaoImpl is its implementation class. This code can also be replaced by <code>UserDaoImpl userdaoimpl = new UserDaoImpl()</code>, but why we don’t do so?</p>
<p>This is about the polymorphism. Knowing an interface can be implemented many times, imaging another implementation is provided and will be used, we name it <code>UserDaoMySQLImpl</code>. If I want to call this class in service layer, I have to rewrite as <code>userDaoMySQLImpl userdaomysqlimpl = new UserDaoMySQLImpl()</code>. If I use the code <code>UserDao userdao = new UserDaoImpl()</code>, I only have to change the <code>new UserDaoImpl()</code> to <code>new UserDaoMySQLImpl()</code>.</p>
<p>After comparing these two codes, I can easily find the use of interface and can feel the sense of polymorphism.</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM读取excel文件更新数据库</title>
    <url>/2020/05/13/SSM%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>模仿新增库存的功能，前端上传excel文件(.xlsx)传入后端实现批量增加。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--        adding support for multipart file upload functionality to servlets and web applications--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!--        Java API To Access Microsoft Format Files--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!--        Java API To Access Microsoft Format Files--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>这里我之前犯了一个错误，我在导入1.3.3版本commons-fileupload的同时，还导入了2.4版本commons-io的依赖，最后启动项目的时候会有冲突，原因是commons-fileupload中已经包含有了commons-io且版本不同，故产生冲突。</p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/batchAdd&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    选择文件:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>enctype就是encodetype就是编码类型的意思。</p>
<p>multipart/form-data是指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思。</p>
<p>需要注意的是：默认情况下，enctype的值是application/x-www-form-urlencoded，不能用于文件上传，只有使用了multipart/form-data，才能完整的传递文件数据。</p>
<p>application/x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件，multipart/form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。</p>
<h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/batchAdd&quot;)</span><br><span class="line">public String batchAdd(MultipartFile file) throws IOException, InvalidFormatException &#123;</span><br><span class="line">   </span><br><span class="line">   String originalFileName = file.getOriginalFilename();  // 获取原文件的名字，这里是books.xlsx</span><br><span class="line">   String myPath = &quot;D:\\fileupload\\&quot;+originalFileName;  </span><br><span class="line">   file.transferTo(new File(myPath)); // 把获取到的文件file转化到目标文件，这里是在目录里创建了一个同样的文件</span><br><span class="line"></span><br><span class="line">   XSSFWorkbook wb = new XSSFWorkbook(new File(myPath));  // 当文件后缀为xlsx时用XSSFWorkbook</span><br><span class="line"></span><br><span class="line">   XSSFSheet xssfSheet = wb.getSheetAt(0); // 因为这文件里只有一张sheet，所以直接getSheetAt(0)写死</span><br><span class="line"></span><br><span class="line">   if (xssfSheet != null) &#123;</span><br><span class="line">       for (int rowNum = 1; rowNum &lt;= xssfSheet.getLastRowNum(); rowNum++) &#123;</span><br><span class="line">           XSSFRow xssfRow = xssfSheet.getRow(rowNum); // 获取行</span><br><span class="line">           Books books = new Books(); // 对每一行创建一个对象</span><br><span class="line">           books.setBookName(xssfRow.getCell(0).getStringCellValue());</span><br><span class="line">           books.setBookCounts((int)xssfRow.getCell(1).getNumericCellValue());</span><br><span class="line">           books.setDetail(xssfRow.getCell(2).getStringCellValue());</span><br><span class="line">           bookService.addBook(books); //执行addBook把每一个对象加进去</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    return &quot;redirect:/book/allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 5:构造函数注入</title>
    <url>/2020/03/29/Spring-Note-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h1><p>之前讨论了setter方法注入，要求在pojo类中要有对应属性的set方法，然后在xml文件中通过<property>标签实现注入。<br>例如：<br>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;name=&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></property></p>
<p>beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h1><p>除了setter方法注入之外，还有构造器注入，这种方法要求pojo类中有构造函数，不要求set方法。xml文件中使用标签<code>&lt;constructor-arg&gt;</code>。<br>例如：<br>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;name=&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;constructor-arg name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h1><p>除了基本的数据类型，int，String之类的，还有Map和List类型，其在xml中对应的配置标签如下。<br>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;String&gt; dream;</span><br><span class="line">    private Map&lt;String,String&gt; score;</span><br><span class="line"></span><br><span class="line">    public User(String name, List&lt;String&gt; dream, Map&lt;String, String&gt; score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.dream = dream;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, dream=&quot; + dream +</span><br><span class="line">                &quot;, score=&quot; + score +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;dream&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;programmer&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;travel&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;score&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;math&quot; value=&quot;90&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;science&quot; value=&quot;80&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User&#123;name=&apos;xliu&apos;, dream=[programmer, travel], score=&#123;math=90, science=80&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，数组对应的标签为<code>&lt;array&gt;</code>,set对应的标签为<code>&lt;set&gt;</code></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring: Factory Pattern</title>
    <url>/2020/06/27/Spring-Factory-Pattern/</url>
    <content><![CDATA[<p>Simple factory:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    private static Properties env = new Properties();</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //Step 1: get IO Stream</span><br><span class="line">            InputStream inputStream = BeanFactory.class.getResourceAsStream(&quot;/applicationContext.properties&quot;);</span><br><span class="line">            //Step 2: load() method reads a property list (key and element pairs) from the input byte stream.</span><br><span class="line">            env.load(inputStream);</span><br><span class="line">            //Stream source doesn&apos;t belong to JVM, so it can&apos;t be handled by GC and needs to be closed mannualy</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        Way to initial an object:</span><br><span class="line">            1. Constructor: UserService userService = new UserServiceImpl();</span><br><span class="line">            2. Refelction: This method can loose coupling</span><br><span class="line">                    Class clazz = Class.forName(&quot;com.baizhiedu.basic.UserServiceImpl&quot;);</span><br><span class="line">	                UserService userService = (UserService)clazz.newInstance();</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public static UserService getUserService() &#123;</span><br><span class="line">        UserService userService = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(env.getProperty(&quot;userService&quot;));</span><br><span class="line">            userService = (UserService) clazz.newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static UserDAO getUserDAO()&#123;</span><br><span class="line">        UserDAO userDAO = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(env.getProperty(&quot;userDAO&quot;));</span><br><span class="line">            userDAO = (UserDAO) clazz.newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return userDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>applicationContext.properties:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Properties extends Hashtable&lt;Object,Object&gt;</span><br><span class="line"># Map: key=String value=String</span><br><span class="line"># Properties [userService = com.baizhiedu.xxx.UserServiceImpl]</span><br><span class="line"># Properties.getProperty(&quot;userService&quot;)</span><br><span class="line"></span><br><span class="line">userService = com.baizhiedu.basic.UserServiceImpl</span><br><span class="line">userDAO = com.baizhiedu.basic.UserDAOImpl</span><br></pre></td></tr></table></figure></p>
<h1 id="General-factory"><a href="#General-factory" class="headerlink" title="General factory"></a>General factory</h1><p>There are lots of redundancy in simple factory like those exceptions in <code>try-catch</code>. Here introduced general factory:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    private static Properties env = new Properties();</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            </span><br><span class="line">            InputStream inputStream = BeanFactory.class.getResourceAsStream(&quot;/applicationContext.properties&quot;);</span><br><span class="line">            env.load(inputStream);</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Object getBean(String key)&#123;</span><br><span class="line">         Object ret = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             Class clazz = Class.forName(env.getProperty(key));</span><br><span class="line">             ret = clazz.newInstance();</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         return ret;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>General factory shares the same <code>applicationContext.properties</code> with simple factory.</p>
<p>How to use general factory:</p>
<ol>
<li>Define class</li>
<li>Inform the factory using <code>applicationContext.properties</code></li>
<li>Get object using BeanFactroy:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object ret = BeanFactory.getBean(&quot;key&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 7: @component</title>
    <url>/2020/03/30/Spring-Note-7-component/</url>
    <content><![CDATA[<p>之前提到在xml文件中，一个bean对应一个类，在MyTest中通过获取bean的方法来创建对象。现在介绍一个新的方法，通过使用注解<code>@Component</code>来代替bean。</p>
<h1 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h1><p>使用注解<code>@Component</code>之前，先在xml文件中添加组件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.xliu.pojo&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>意思为自动扫描路径com.xliu.pojo中所有的<code>@Component</code>。<br>在pojo类前添加注解<code>@Component</code>意思是告诉Spring，我是一个pojo类，请将我注册到容器中。</p>
<h1 id="使用前"><a href="#使用前" class="headerlink" title="使用前"></a>使用前</h1><p>假设我们有一个pojo类User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在xml中注册的bean为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>MyTest:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    User user = (User) applicationContext.getBean(&quot;user&quot;);</span><br><span class="line">    System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xliu</span><br></pre></td></tr></table></figure></p>
<h1 id="使用后"><a href="#使用后" class="headerlink" title="使用后"></a>使用后</h1><p>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(&quot;xiaokeliu&quot;)</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@Component</code>表示组件，注册到Spring中，<code>@Value</code>表示对属性name的赋值<br>applicationContext.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.xliu.pojo&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>在xml文件中只需要这一行添加组件即可。<br>MyTest不变，结果输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xiaokeliu</span><br></pre></td></tr></table></figure></p>
<p>事实证明，虽然在xml文件中我们没有显式地注册bean，但还是可以通过getBean来创建对象。</p>
<h1 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h1><p><code>@Component</code> 有几个衍生注解，我们在web开发中，会按照MVC三层架构分层</p>
<ul>
<li>dao(@Repository)</li>
<li>service(@Service)</li>
<li>controller(@Controller)<br>功能和<code>@Component</code>一样，都是代表这个类注册到Spring容器中，装配。</li>
</ul>
<h1 id="XML与注解最佳实践"><a href="#XML与注解最佳实践" class="headerlink" title="XML与注解最佳实践"></a>XML与注解最佳实践</h1><p>XML用来管理bean，注解负责完成属性的注入。<br>那么XML文件中就只有一个一个<code>&lt;bean&gt;</code>，而给属性赋值则通过注解(@Value)实现。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 4: 第一个程序</title>
    <url>/2020/03/28/Spring-Note-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="XML文件模板"><a href="#XML文件模板" class="headerlink" title="XML文件模板"></a>XML文件模板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  </span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用Spring来创建对象"><a href="#使用Spring来创建对象" class="headerlink" title="使用Spring来创建对象"></a>使用Spring来创建对象</h1><p>在Spring中，通过配置文件<code>beans.xml</code>来创建对象，通常来说一个类对应一个bean。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.xliu.dao.UserDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;userDaoMysql&quot; class=&quot;com.xliu.dao.UserDaoMysqlImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.xliu.service.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDaoMysql&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>id = 变量名</p>
<p>class = new的对象</p>
<p>property相当于给对象中的属性设置一个值,只要有一个属性，就写一个<property>来赋值</property></p>
<p>因为在com.xliu.service.UserServiceImpl这个类中，有setUserDao这个方法，因此name=”userDao”, ref=”userDaoMysql”代表的是创建对象的类，ref的值对应bean的id。</p>
<h1 id="MyTest"><a href="#MyTest" class="headerlink" title="MyTest"></a>MyTest</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.xliu.dao.UserDao;</span><br><span class="line">import com.xliu.dao.UserDaoImpl;</span><br><span class="line">import com.xliu.dao.UserDaoMysqlImpl;</span><br><span class="line">import com.xliu.service.UserService;</span><br><span class="line">import com.xliu.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Mytest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        获取Spring的上下文对象</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">//        我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以了</span><br><span class="line">        UserServiceImpl userService = (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>MySQL获取用户数据</code></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>如果需要使用别的UserDao实现类，只需要在配置文件中改ref的值，例如<code>ref=&quot;userDao&quot;</code>，即可输出<code>获取用户数据</code></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security: Set up</title>
    <url>/2020/07/24/Spring-Security-Set-up/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>State-based Testing</title>
    <url>/2019/11/19/State-based-Testing/</url>
    <content><![CDATA[<h1 id="Generate-a-state-machine"><a href="#Generate-a-state-machine" class="headerlink" title="Generate a state machine"></a>Generate a state machine</h1><ol>
<li>Create a txt file and write code </li>
<li>Change the suffix .txt into .sm</li>
<li>Download SMC</li>
<li>Command Line: <code>java -jar Smc.jar -java Seminar.sm</code>, a new java file ‘SeminarContext.java’ created</li>
<li>Command Line: <code>java -jar Smc.jar -graph Seminar.sm</code>, a new dot file ‘Seminar_sm.dot’ created</li>
<li>Download Graphviz and do configuration</li>
<li>Command Line: <code>dot -Tpng Seminar_sm.dot -o Seminar.png</code>, a new png file ‘Seminar.png’ created</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Django学习笔记：第一个Django应用</title>
    <url>/2019/08/04/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AADjango%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite  # mysite为工程名</span><br></pre></td></tr></table></figure>
<p>此时的文件目录结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>mysite/</strong>: 整个项目的容器，没有太大意义，名字可以随意更改</li>
<li><strong>manage.py</strong>: 命令行工具，用来管理Django项目</li>
<li><strong>mysite/</strong>: 当前Django工程所使用的Python包</li>
<li><strong>__init__.py</strong>: 表明当前文件夹是一个Python包</li>
<li><strong>settings.py</strong>: 配置文件</li>
<li><strong>urls.py</strong>: 路由配置文件</li>
<li><strong>wsgi.py</strong>: 兼容WSGI的Web服务入口</li>
</ul>
<h2 id="运行工程"><a href="#运行工程" class="headerlink" title="运行工程"></a>运行工程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<h2 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h2><p><strong>工程(Project)和程序(App):</strong> 应用程序是真正工作的组件，例如一个博客系统或者投票系统。工程师包含网站配置信息和应用程序等的集合，一个工程可以包含多个应用程序，而一个应用程序可以属于多个工程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp polls  # 创建一个名为polls的投票程序</span><br></pre></td></tr></table></figure></p>
<p>polls的目录结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polls\</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">views.py</span><br></pre></td></tr></table></figure></p>
<h2 id="配置数据库以及创建模型"><a href="#配置数据库以及创建模型" class="headerlink" title="配置数据库以及创建模型"></a>配置数据库以及创建模型</h2><p>&emsp;&emsp;使用Django自带的数据库SQLite。</p>
<p>&emsp;&emsp;现在，我们来定义模型model，模型本质上就是数据库表的布局，再附加一些元数据。<br>&emsp;&emsp;Django通过自定义Python类的形式来定义具体的模型，每个模型的物理存在方式就是一个Python的类Class，每一个类都是django.db.models.Model的子类。每一个字段都是Field类的一个实例，例如用于保存字符数据的CharField和用于保存时间类型的DateTimeField，它们告诉Django每一个字段保存的数据类型。每个模型代表数据库中的一张表，每个类的实例代表数据表中的一行数据，类中的每个变量代表数据表中的一列字段。<br>&emsp;&emsp;Django通过模型，将Python代码和数据库操作结合起来，实现对SQL查询语言的封装。也就是说，你可以不会管理数据库，可以不会SQL语言，你同样能通过Python的代码进行数据库的操作。Django通过ORM对数据库进行操作，奉行代码优先的理念，将Python程序员和数据库管理员进行分工解耦。<br>&emsp;&emsp;示例代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># polls/models.py</span><br><span class="line"></span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Question(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=200)</span><br><span class="line">    pub_date = models.DateTimeField(&apos;date published&apos;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=200)</span><br><span class="line">    votes = models.IntegerField(default=0)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以在每个Field中使用一个可选的第一位置参数用于提供一个人类可读的字段名，让你的模型更友好，更易读，并且将被作为文档的一部分来增强代码的可读性，如例子中的pub_date。<br>&emsp;&emsp;使用ForeignKey定义了一个外键关系。它告诉Django，每一个Choice关联到一个对应的Question（注意要将外键写在‘多’的一方）。Django支持通用的数据关系：一对一，多对一和多对多，如例子中的question。</p>
<h2 id="启用模型"><a href="#启用模型" class="headerlink" title="启用模型"></a>启用模型</h2><p>&emsp;&emsp;把polls加入mysite/settings.py中的INSTALLED_APPS让项目知道该应用的存在。<br>&emsp;&emsp;运行命令<code>$ python manage.py makemigrations polls</code>将数据模型的改动保存为一个’migration’<br>&emsp;&emsp;运行命令<code>$ python manage.py migrate</code>对数据库执行真正的迁移动作。在这一步中会自动生成表，表明为“应用名_模型名（小写）”的组合，自动添加主键id并且按照惯例在外键字段名上附加“_id”。</p>
<h2 id="开发视图"><a href="#开发视图" class="headerlink" title="开发视图"></a>开发视图</h2><p>&emsp;&emsp;Django的视图是负责页面展示的重要模块，用于处理网站业务逻辑。<br>&emsp;&emsp;打开polls/view.py文件，每个视图至少做两件事之一：返回一个包含请求页面的HttpResponse对象或者弹出一个类似Http404的异常。其它的则自己定义。<br>&emsp;&emsp;render()方法： 从Django.shortcuts导入render，将加载模板、传递参数、返回HttpResponse对象整合一起。第一个位置参数是请求对象(就是view函数的第一个参数)，第二个参数是模板，第三个参数是字典，包含需要传递给模板的数据。最后render函数返回一个经过字典数据渲染过的模板封装而成的HttpResponse对象。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    latest_question_list = Question.objects.order_by(&apos;-pub_date&apos;)[:5]</span><br><span class="line">    context = &#123;&apos;latest_question_list&apos;: latest_question_list&#125;</span><br><span class="line">    return render(request, &apos;polls/index.html&apos;, context)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;创建视图后，为了能够访问它，需要在URL中添加路由映射。在polls中创建文件urls.py:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;&apos;, views.index, name=&apos;index&apos;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来需要在根目录的urls.py中引用polls/urls.py，修改mysite/urls.py:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)),</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面代码中include()方法可以用来引用其他URLconfs(urls.py)。出了admin.site.urls之外，在任何时候都应该使用include()方法引用其他路由模块。</p>
<h2 id="模板系统"><a href="#模板系统" class="headerlink" title="模板系统"></a>模板系统</h2><p>&emsp;&emsp;Django提供的模板系统可以解耦视图和模板之间的硬连接。<br>&emsp;&emsp;首先，在polls目录下创建一个新的templates目录，Django会在它里面查找模板文件。<br>&emsp;&emsp;项目的 TEMPLATES配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls 的模板位置的原因。<br>&emsp;&emsp;在templates目录中，再创建一个新的子目录名叫polls，进入该子目录，创建一个新的html文件index.html。换句话说，你的模板文件应该是polls/templates/polls/index.html。因为 Django 会寻找到对应的app_directories ，所以你只需要使用polls/index.html就可以引用到这一模板了。<br>&emsp;&emsp;在视图view.py中通过render()向模板中的页面传递的上下文变量可以直接使用，例如在detail()视图里通过<code>return render(request, &#39;polls/detail.html&#39;, {&#39;question&#39;: question})</code>传递的question在模板polls/detail.html中通过<code>question.question_text</code>使用</p>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>&emsp;&emsp;运行命令<code>$ python manage.py createsuperuser</code>创建一个可以登录admin站点的用户，填入所需信息后通过<a href="http://127.0.0.1:8000/admin/即可访问。" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/即可访问。</a><br>随后为了让应用的信息可以在后台显示，打开polls/admin.py注册投票应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>李健.《Django 2.0入门与实践》.清华大学出版社<br><a href="http://www.liujiangblog.com/" target="_blank" rel="noopener">刘江的博客教程</a></p>
</blockquote>
<hr>
<h1 id="更新-2019-08-15"><a href="#更新-2019-08-15" class="headerlink" title="更新 2019-08-15"></a>更新 2019-08-15</h1><h2 id="使用MySQL的配置方案"><a href="#使用MySQL的配置方案" class="headerlink" title="使用MySQL的配置方案"></a>使用MySQL的配置方案</h2><p>./settings.py:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;NAME&apos;: &apos;NewTest&apos;,</span><br><span class="line">        &apos;HOST&apos;: &apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;USER&apos;: &apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;: &apos;pwd&apos;,</span><br><span class="line">        &apos;PORT&apos;: &apos;3306&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="记载数据库驱动"><a href="#记载数据库驱动" class="headerlink" title="记载数据库驱动"></a>记载数据库驱动</h2><p>./<strong>init</strong>.py:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()  # 完成数据库的驱动加载</span><br></pre></td></tr></table></figure></p>
<h2 id="解决mysqlclient版本问题"><a href="#解决mysqlclient版本问题" class="headerlink" title="解决mysqlclient版本问题"></a>解决mysqlclient版本问题</h2><p>base.py 中搜索:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version = Database.version_info</span><br></pre></td></tr></table></figure></p>
<p>行内添加一个pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raise ImproperlyConfigured(&apos;mysqlclient 1.3.13 or newer is required; you have %s.&apos; % Database.version)</span><br></pre></td></tr></table></figure>
<p>如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if version &lt; (1, 3, 13):</span><br><span class="line">   pass</span><br><span class="line">   &apos;&apos;&apos;</span><br><span class="line">   raise ImproperlyConfigured(</span><br><span class="line">       &apos;mysqlclient 1.3.13 or newer is required; you have %s.&apos;</span><br><span class="line">       % Database.__version__</span><br><span class="line">   )</span><br><span class="line">   &apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p>
<p>保存关闭并打开 operations.py搜索<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query = query.decode(errors=&apos;replace&apos;)</span><br></pre></td></tr></table></figure></p>
<p>decode换为encode:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query = query.encode(errors=&apos;replace&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用MySQL要注意自己创建数据库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &lt;NAME&gt;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>官方文档：Django shortcut functions</title>
    <url>/2019/08/16/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9ADjango-shortcut-functions/</url>
    <content><![CDATA[<p>django.shortcuts包整合了“跨越”MVC中很多层的方法和类。</p>
<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render(request,template_name,context=None,content_type=None,status=None,using=None)</span><br></pre></td></tr></table></figure>
<p>将一个已有的模板和一个已有的字典结合起来并且返回一个带有被渲染的文本的HttpResponse对象。<br>Django不提供返回TemplateResponse的快捷方式因为render()和TemplateResponse的构造器一样方便。</p>
<h2 id="必须参数"><a href="#必须参数" class="headerlink" title="必须参数"></a>必须参数</h2><ol>
<li>request<br>&emsp;&emsp;用来生成这个response的request对象。</li>
<li>template_name<br>&emsp;&emsp;要使用的模板或模板序列的全名。如果给了一个序列，那么将会使用第一个已存在的模板。</li>
</ol>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><ol>
<li>context<br>&emsp;&emsp;一个字典，里面的值被加入模板文本中。默认情况下这是一个空字典。如果字典中的值是可调用的，视图会在渲染模板之前调用它。</li>
<li>context_type<br>&emsp;&emsp;The MIME type to use for the resulting document. Defaults to the value of the DEFAULT_CONTENT_TYPE setting.</li>
<li>status<br>&emsp;&emsp;响应状态码，默认为200。</li>
<li>using<br>&emsp;&emsp;用来加载模板的模板引擎的名字。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 1: p-namespace &amp; c-namespace</title>
    <url>/2020/01/01/Spring-Note-1-p-namespace-c-namespace/</url>
    <content><![CDATA[<h1 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h1><p>As we already know, we can define bean properties and constructor arguments as references to other managed beans or as values defined inline.<br>Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition.</p>
<h1 id="XML-Shortcut-with-the-p-namespace"><a href="#XML-Shortcut-with-the-p-namespace" class="headerlink" title="XML Shortcut with the p-namespace"></a>XML Shortcut with the p-namespace</h1><p>Before using p-namespace, we register a class in configuration file with <code>&lt;property&gt;</code> label to define the value of parameter. So I personally think p means property here.</p>
<h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h2><p>Add a new namespace in <beans> as :<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code><br>The format of using p-namespace is:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;</span><br><span class="line">    p:attr=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure></beans></p>
<p>where id and class mean the same as before, <code>p:attr=&quot;&quot;</code> means defining the value of a certain parameter </p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>userbeans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.xliu.pojo.User&quot; p:age=&quot;18&quot; p:name=&quot;xliu&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>equals to:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>in this example, the value of user and age is defined in <code>userbeans.xml</code></p>
<h1 id="XML-Shortcut-with-the-c-namespace"><a href="#XML-Shortcut-with-the-c-namespace" class="headerlink" title="XML Shortcut with the c-namespace"></a>XML Shortcut with the c-namespace</h1><p>Before using c-namespace, we register a class in configuration file with <code>&lt;constructor-arg&gt;</code> label to initialize the constructor method. So I personally think c means constructor here.</p>
<h2 id="How-to-use-1"><a href="#How-to-use-1" class="headerlink" title="How to use"></a>How to use</h2><p>Add a new namespace in <beans> as :<code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code><br>The format of using p-namespace is:<br><code>&lt;bean id=&quot;&quot; class=&quot;&quot; c:age=&quot;&quot; c:name=&quot;&quot;/&gt;</code><br>where id and class mean the same as before, <code>c:attr=&quot;&quot;</code> means defining the constructor’s parameter</beans></p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><p>User.java<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xliu.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Different from previous section, I added one constructor with two parameter, age and name, here. Otherwise c-namespace will not be used</p>
<p>userbeans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;com.xliu.pojo.User&quot; c:age=&quot;19&quot; c:name=&quot;liux&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>equals to:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;com.xliu.pojo.User&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;xliu&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>Same, the constructor is defined.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Both p-namespace and c-namespace can be replaced by either<code>&lt;property&gt;</code>or<code>&lt;constructor-arg&gt;</code>, they are more elegant alternatives.</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 8:JavaConfig</title>
    <url>/2020/03/30/Spring-Note-8-JavaConfig/</url>
    <content><![CDATA[<blockquote>
<p>The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.<br>The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s<code>&lt;beans/&gt;</code> XML configuration, the @Bean annotation plays the same role as the <code>&lt;bean/&gt;</code> element. You can use @Bean-annotated methods with any Spring @Component. However, they are most often used with @Configuration beans.<br>Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class.</p>
</blockquote>
<p>使用Config开发可以省略配置文件。<br>LiuConfig.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component</span><br><span class="line">// @Configuration代表这是一个配置类，就和之前的Beans.xml一样</span><br><span class="line">@Configuration</span><br><span class="line">public class LiuConfig &#123;</span><br><span class="line"></span><br><span class="line">//    注册一个bean，相当于之前写的一个bean标签</span><br><span class="line">//    方法的名字就相当于bean标签的id属性</span><br><span class="line">//    方法的返回值，就相当于bean标签中的class属性</span><br><span class="line">    @Bean</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>User.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(&quot;XLIU&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyTest.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        如果完全使用了配置类方法去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载</span><br><span class="line">       ApplicationContext applicationContext = new AnnotationConfigApplicationContext(LiuConfig.class);</span><br><span class="line">       User user = applicationContext.getBean(&quot;user&quot;, User.class);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Note 6: beans作用域</title>
    <url>/2020/03/30/Spring-Note-6-beans%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.</p>
<h1 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h1><p>假设beans.xml:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;userService&quot; class=&quot;Service.UserServiceImpl&quot; scope=&quot;singleton&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>那么通过这个bean创建的对象，地址都是一样的。<br>MyTest.java:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserService userService = (UserService) classPathXmlApplicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">UserService userService2 = (UserService) classPathXmlApplicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">System.out.println(userService==userService2);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>同上，如果把bean中的scope属性的值改为prototype，那么每一次使用这个bean都会创建一个新的对象。<br>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>singleton在容器中，只被实例化一次，而prototype在容器中，调用几次，就被实例化几次；</li>
<li>在AppplicationContext容器中，singleton在applicaitonContext.xml加载时就被预先实例化，而prototype必须在调用时才实例化</li>
<li>singleton比prototype消耗性能，在web开发中，推荐使用singleton模式，在app开发中，推荐使用prototype模式。</li>
</ol>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>（译）&quot;related_name&quot; in models.py</title>
    <url>/2019/08/13/%EF%BC%88%E8%AF%91%EF%BC%89related_name%20in%20models.py/</url>
    <content><![CDATA[<p>&emsp;&emsp;假设你有一个叫Book的模型和一个叫Category的模型。每本书只属于一个分类，用一个外键表示。因此你的模型设计如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Category(models.Model):</span><br><span class="line">    name = models.CharFeild(max_length=128)</span><br><span class="line"></span><br><span class="line">class Book(modesl.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果你有一个Book实例，你可以通过对应的field访问它的分类。并且，如果你有一个分类的实例，默认情况下Django会添加一个叫做”book_set”的属性，这个属性返回该分类下所有书的集合，因此可以进行如下操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tst.models import Category, Book</span><br><span class="line">category = Category.objects.get(pk=1)</span><br><span class="line">print(&quot;Books in &quot;+category.name)</span><br><span class="line">for book in category.book_set.all():</span><br><span class="line">    print(book.name)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;book_set是一个django默认给我们构造的属性，通过外键的related_name属性可以给这个属性换个名字，比如说如果用<code>category = models.ForeighKey(Category, related_name=&#39;book_collection&#39;)</code>定义一个分类，我可以用<code>category.book_collection.all()</code>而不是<code>category.book_set.all()</code>。<br>&emsp;&emsp;大多数情况下都不需要修改related_name，而且django默认的x_set很好记。然而有一种情况下必须要用related_name：当你有多个从一个模型到另一个模型的外键时。这种情况下可能会产生冲突（因为django会尝试给同一个模型创建两个x_set属性）。<br>&emsp;&emsp;例如，如果我的Book模型如下（有一个分类和一个子分类）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category)</span><br><span class="line">    sub_category = models.ForeignKey(Category)</span><br></pre></td></tr></table></figure></p>
<p>于是模型不会生效除非你给一个（或两个）外键related_name属性，因此冲突就解决了。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Books(models.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category, related_name=&apos;book_category_set&apos;)</span><br><span class="line">    sub_category = models.ForeignKey(Category, related_name=&apos;book_sub_category_set&apos;)</span><br></pre></td></tr></table></figure></p>
<h1 id="原文连接"><a href="#原文连接" class="headerlink" title="原文连接"></a>原文连接</h1><p><a href="https://www.reddit.com/r/django/comments/76a7uw/related_name_in_modelspy/" target="_blank" rel="noopener">Reddit</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：GC机制</title>
    <url>/2019/08/23/Java%EF%BC%9AGC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在 C/C++中，编程者需要同时负责对象的创建与销毁。通常情况下编程者会忘记销毁无用的对象。由于这种忽视，在某个时间点可能会没有足够的内存空间去创建新的对象从而导致整个程序因为内存溢出而终止。</li>
<li>在Java中，编程者不需要关心哪个对象不会再被用上。垃圾收集器会销毁这些对象。</li>
<li>垃圾收集器是守护线程的最好例子因为它总是在后台运行。</li>
<li>垃圾收集器的主要目的是通过摧毁不可到达的对象从而释放内存堆。<h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2></li>
</ul>
<ol>
<li>不可到达的对象(Unreachable objects): 如果一个对象没有任何指向它的索引那么我们称之为不可到达的对象。同样注意到属于隔离岛一部分的对象也是不可到达的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i = new Integer(4);</span><br><span class="line">// 通过i中的索引，这个新的整型对象是可到达的</span><br><span class="line">i = null;</span><br><span class="line">// 那个整型对象不可到达了</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="//xiaokeliu666.github.io/2019/08/23/Java：GC机制/reference.png" alt="img"></p>
<ol>
<li>垃圾收集的合格性(Eligibility for garbage collection)：如果一个对象是不可到达的，那么就可以被垃圾收集。在上图中，在<code>i = null;</code>之后堆空间中的整型对象4就可以被垃圾收集了。</li>
</ol>
<h1 id="使对象可以被垃圾收集的方法"><a href="#使对象可以被垃圾收集的方法" class="headerlink" title="使对象可以被垃圾收集的方法"></a>使对象可以被垃圾收集的方法</h1><ul>
<li>即使编程者不需要负责摧毁无用的对象，但还是推荐把不再需要的对象变得不可到达。</li>
<li>通常有四种方法让对象变得可以被垃圾收集。<ol>
<li>让引用变量为空</li>
<li>重新分配引用变量</li>
<li>在方法内部创建对象</li>
<li>隔离岛</li>
</ol>
</li>
</ul>
<h1 id="请求JVM运行垃圾收集器的方法"><a href="#请求JVM运行垃圾收集器的方法" class="headerlink" title="请求JVM运行垃圾收集器的方法"></a>请求JVM运行垃圾收集器的方法</h1><ul>
<li>一旦我们让对象可以被垃圾收集，它可能不会立即被垃圾收集器销毁。无论何时JVM运行垃圾收集程序，只有对象会被销毁。但是当JVM运行垃圾收集器，我们不能预计。</li>
<li>我们也可以请求JVM运行垃圾收集器。有以下两种方法：<ol>
<li>使用<code>System.gc()</code>方法: System类包含静态方法gc()来请求JVM运行垃圾收集器。</li>
<li>使用<code>Runtime.getRuntime().gc()</code>方法： Runtime类允许应用程序与运行应用程序的JVM进行交互。于是通过使用它的<code>gc()</code>方法，我们可以请求JVM运行垃圾收集器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Java程序描述请求JVM去运行垃圾收集器</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        Test t1 = new Test();</span><br><span class="line">        Test t2 = new Test();</span><br><span class="line"></span><br><span class="line">        //让引用变量为空</span><br><span class="line">        t1 = null;</span><br><span class="line"></span><br><span class="line">        //请求JVM运行垃圾收集器</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        //让引用变量为空</span><br><span class="line">        t2 = null;</span><br><span class="line"></span><br><span class="line">        //请求JVM运行垃圾收集器</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    // finalize method is called on object once</span><br><span class="line">    // before garbage collecting it</span><br><span class="line">    protected void finalize() thorws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Garbage collector called&quot;);</span><br><span class="line">        System.out.println(&quot;Object garbage collected:&quot; + this);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ol>
<li>无法保证以上两种方式中的任何一种绝对会运行垃圾处理器。</li>
<li>调用两种方法在效率上是等价的。</li>
</ol>
<h1 id="Finalization"><a href="#Finalization" class="headerlink" title="Finalization"></a>Finalization</h1><ul>
<li>在销毁对象之前，垃圾收集器对对象调用finalize()方法来执行清理动作。一旦finalize()方法完成，垃圾收集器销毁对象。</li>
<li>fianlize()方法出现在Object类里，该方法的访问修饰符为protected，原型如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void finalize() throws Throwable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据我们的需求，我们可以重写finalize()方法来执行我们的清理动作比如关闭数据库的连接。</p>
<p>注意：</p>
<ol>
<li>finalize()是由垃圾收集器调用的而不是JVM。虽然垃圾收集器是JVM的一个模型。</li>
<li>Object类finalize()方法的执行为空，因此如果要部署系统资源或者执行其他清理的话需要重载这个方法。</li>
<li>finalize()方法不会对一个对象调用多次。</li>
<li>如果finalize()方法抛出了一个不可捕捉的异常，异常会被忽略而且对象的终结会被终止。</li>
</ol>
<h1 id="垃圾收集器的使用"><a href="#垃圾收集器的使用" class="headerlink" title="垃圾收集器的使用"></a>垃圾收集器的使用</h1><p>假设要写一个程序去计算公司中工作的员工数（除去实习生），你需要垃圾收集器来完成这个程序。<br>任务描述：<br>写一个程序创建一个叫做Employee的类包含以下的数据成员：</p>
<ol>
<li>ID，存储分配给每个员工的独一无二的id</li>
<li>员工的姓名</li>
<li>员工的年龄<br>同时提供以下方法：</li>
<li>一个带参构造函数用来初始化姓名和年龄，ID需要在构造器中被初始化</li>
<li>一个show()方法去展示ID,姓名和年龄</li>
<li>一个showNextId()去展示每个员工的下一个ID<br>作为一个没有垃圾收集器知识的初学者会这样写：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private int ID;</span><br><span class="line">    private  String name;</span><br><span class="line">    private  int age;</span><br><span class="line">    private static int nextId=1;</span><br><span class="line"></span><br><span class="line">    public Employee(String name, int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.ID = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;Id=&quot;+ID+&quot;\nName=&quot;+name+&quot;\nAge=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void showNextId()&#123;</span><br><span class="line">        System.out.println(&quot;Next employee id of &quot;+ID&quot; will be=&quot;+nextId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Employee E = new Employee(&quot;GFG1&quot;, 56);</span><br><span class="line">        E.showNextId();</span><br><span class="line">        Employee F = new Employee(&quot;GFG2&quot;, 45);</span><br><span class="line">        F.showNextId();</span><br><span class="line">        Employee G = new Employee(&quot;GFG3&quot;, 25);</span><br><span class="line">        G.showNextId();                                </span><br><span class="line">        &#123;</span><br><span class="line">            //用块来保存实习生</span><br><span class="line">            Employee X = new Employee(&quot;GFG4&quot;, 23);</span><br><span class="line">            X.showNextId();</span><br><span class="line">            Employee Y = new Employee(&quot;GFG5&quot;, 21);</span><br><span class="line">            Y.showNextId();                               </span><br><span class="line">        &#125;</span><br><span class="line">        G.showNextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next employee id of 1 will be=2</span><br><span class="line">Next employee id of 2 will be=3</span><br><span class="line">Next employee id of 3 will be=4</span><br><span class="line">Next employee id of 4 will be=5</span><br><span class="line">Next employee id of 5 will be=6</span><br><span class="line">Next employee id of 3 will be=6</span><br></pre></td></tr></table></figure></p>
<p>类的定义中nextId属性为静态，被所有对象共享。第一个G.showNextId()输出的是4，第二个G.showNextId()输出的是6。<br>如何获得获得正确的输出（即让第二个G.showNextId()输出4）：<br>现在垃圾收集器会看到两个空闲的对象，现在去减少nextId的值，垃圾收集器只有在编程者在类中重载的情况下才会调用方法finalize()。正如之前提到的，我们需要向垃圾收集器发起请求，我们要在子块的中写下一下三个步骤：</p>
<ol>
<li>将引用变量设为空</li>
<li>调用System.gc();</li>
<li>调用System.runFinalization();<br>现在计算员工（除了实习生）的正确代码是：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private int ID;</span><br><span class="line">    private  String name;</span><br><span class="line">    private  int age;</span><br><span class="line">    private static int nextId=1;</span><br><span class="line"></span><br><span class="line">    public Employee(String name, int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.ID = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;Id=&quot;+ID+&quot;\nName=&quot;+name+&quot;\nAge=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void showNextId()&#123;</span><br><span class="line">        System.out.println(&quot;Next employee id of &quot;+ID&quot; will be=&quot;+nextId);</span><br><span class="line">    &#125;</span><br><span class="line">    // 供gc调用</span><br><span class="line">    protected void finalize()&#123;</span><br><span class="line">    --nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Employee E = new Employee(&quot;GFG1&quot;, 56);</span><br><span class="line">        E.showNextId();</span><br><span class="line">        Employee F = new Employee(&quot;GFG2&quot;, 45);</span><br><span class="line">        F.showNextId();</span><br><span class="line">        Employee G = new Employee(&quot;GFG3&quot;, 25);</span><br><span class="line">        G.showNextId();                                </span><br><span class="line">        &#123;</span><br><span class="line">            //用块来保存实习生</span><br><span class="line">            Employee X = new Employee(&quot;GFG4&quot;, 23);</span><br><span class="line">            X.showNextId();</span><br><span class="line">            Employee Y = new Employee(&quot;GFG5&quot;, 21);</span><br><span class="line">            Y.showNextId();  </span><br><span class="line">            X = Y = null;  // 设置为空</span><br><span class="line">            System.gc();  //调用垃圾收集器</span><br><span class="line">            System.runFinalization();     // 执行finalize                         </span><br><span class="line">        &#125;</span><br><span class="line">        G.showNextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next employee id of 1 will be=2</span><br><span class="line">Next employee id of 2 will be=3</span><br><span class="line">Next employee id of 3 will be=4</span><br><span class="line">Next employee id of 4 will be=5</span><br><span class="line">Next employee id of 5 will be=6</span><br><span class="line">Next employee id of 3 will be=4</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://www.geeksforgeeks.org/garbage-collection-java/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
</blockquote>
<hr>
<p>Q. How do you force garbage collection to occur at a certain point?<br>A. Call System.forceGc()<br>B. Call System.gc()<br>C. Call System.requireGc()<br>D. None of the above</p>
<p>Answer: D<br>While you can suggest to the JVM that it might want to run a garbage collection cycle, the JVM is free to ignore your suggestion.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：多态</title>
    <url>/2019/08/30/Java%EF%BC%9A%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>这几天把《Java编程思想》中的第八章多态看了几遍，感觉相比其它两大特性（封装、继承）而言，多态更抽象，更难理解，运用起来更加灵活，当然这只是我目前而言的感受，在以后可能会有更深入的理解，现在能做的只有先把书中学到的东西先记录下来巩固一下，以后有新的收获再更新。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。<br>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一个基类导出来的，多态也称作动态绑定、后期绑定或运行时绑定。</p>
<h1 id="向上整型"><a href="#向上整型" class="headerlink" title="向上整型"></a>向上整型</h1><p>对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。把某个对象的引用视为对其基类型的引用的做法被称作向上转型。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Instrument &#123;</span><br><span class="line">    // 基类乐器，方法play()</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        // 输出&quot;Instrument.play()&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Wind extends Instrument &#123;</span><br><span class="line">    // 管乐器类继承乐器基类，并重写了play()方法</span><br><span class="line">    public void play(Note n) &#123;</span><br><span class="line">        // 输出&quot;Wind.play()&quot; + n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Music &#123;</span><br><span class="line">    public static void tune(Instrument i) &#123;</span><br><span class="line">        // tune()方法：乐器对象调用play()，默认参数为Note.MIDDLE_C</span><br><span class="line">        i.play(Note.MIDDLE_C)</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wind flute = new Wind();</span><br><span class="line">        tune(flute); //向上转型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wind.play() MIDDLE_C</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>Music类中的tune()方法的参数列表中接受的参数是乐器类的对象，但是主函数中我们传入的对象是Wind类的，但是仍然输出了正确的结果，这就是向上转型的多态。从Wind向上转型到Instrument可能会”缩小“接口，但不会比Instrument的全部接口更窄。</p>
<h2 id="仅接受基类"><a href="#仅接受基类" class="headerlink" title="仅接受基类"></a>仅接受基类</h2><p>首先我们梳理一下上例：1.tune()方法接受的对象为Instrument类型对象；2.主函数中传入的对象为Wind类。<br>基于上述例子中我们可以想象，如果Instrument的子类有很多个的话，如果要实现同样的功能，会多出很多代码量并且代码看上去会非常的冗杂：我们要给各个子类单独创造对象，然后分别传入tune()方法。这样的代码会有很大一部分是类似的，因此我们会想办法：我们能不能写一个方法，仅接受基类作为参数，而不是子类。也就是说，如果我们不管子类的存在，编写的代码只与基类打交道会不会更好呢？<br>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Shape &#123;</span><br><span class="line">    public void draw() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        // 输出&quot;Circle.draw()&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Square extends Shape &#123;</span><br><span class="line">    // 同上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Triangle extends Shape &#123;</span><br><span class="line">    // 同上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RandomShapeGenerator &#123;</span><br><span class="line">    private Random rand = new Random(47);</span><br><span class="line">    public Shape next() &#123;</span><br><span class="line">        switch(rand.nextInt(3)) &#123;</span><br><span class="line">            default:</span><br><span class="line">            case 0: return new Circle();</span><br><span class="line">            case 1: return new Square();</span><br><span class="line">            case 2: return new Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Shapes &#123;</span><br><span class="line">    private static RandomShapeGenerator gen = new RandomShapeGenerator();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape[] s = new Shape[9];</span><br><span class="line">        for(int i = 0; i &lt; s.length; i++)</span><br><span class="line">            s[i] = gen.next();</span><br><span class="line">        for(Shape shp : s)</span><br><span class="line">            shp.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Triangle.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Square.draw()</span><br><span class="line">Triangle.draw()</span><br><span class="line">Circle.draw()</span><br></pre></td></tr></table></figure></p>
<p>分析：三个子类（Triangle,Circle,Sauqre）继承自一个基类（Shape）。RandomShapeGenerator类中的next()方法负责生成不同子类对象并最终返回一个Shape类型的对象（这其中包括了一个向上转型的过程在return里）。因此当我们在主函数中调用next()方法时，只能获得一个Shape的引用，是不知道具体是哪个子类的，主函数中通过调用next()方法随机生成9个对象并且装进Shape类型的数组中，然后让数组中的每个对象执行draw()方法。通过分析输出我们很容易就能得出结论，与子类型有关的特定行为正确地发生了。<br>结论：在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。（第一个代码的例子中，把<code>Wind flute = new Wind()</code>改成<code>Instrument flute = new Wind()</code>也能获得正确结果）</p>
<h2 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h2><p>之前举的例子都只有一层继承，除了Instrument外，都是它的子类。现在我们添加一层继承：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Woodwind extends Wind &#123;</span><br><span class="line">    void play(Note n) &#123;</span><br><span class="line">        System.out.println(&quot;Woodwind.play() &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数中执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Instrument woodwind = new Woodwind();</span><br><span class="line">tune(woodwind);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FakeWind.play()MIDDLE_C</span><br></pre></td></tr></table></figure></p>
<p>分析：多层继承并不会影响结果的正确输出。<br>总结：我们所做的代码修改，不会对程序中其他不应受到影响的部分产生破坏。换句话说，多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><h2 id="覆盖私有方法"><a href="#覆盖私有方法" class="headerlink" title="覆盖私有方法"></a>覆盖私有方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PrivateOverride &#123;</span><br><span class="line">    private void f() &#123;</span><br><span class="line">        System.out.println(&quot;private f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PrivateOverride po = new Derived();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Derived extends PrivateOverride &#123;</span><br><span class="line">    public void f() &#123;</span><br><span class="line">        System.out.println(&quot;public f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private f()</span><br></pre></td></tr></table></figure></p>
<p>分析：Derived类为PrivateOverride类的子类，并且尝试重写f()方法。主函数中用PrivateOverride引用指向一个Derived对象，根据之前的向上转型原则，我们期待的输出应该是”public f()”，但是输出是”private f()”。原因在于private方法被自动认为是final方法，而且对导出类是屏蔽的。因此，在这种情况下，Derived类中的f()方法就是一个全新的方法；既然基类中的f()方法在子类Derived中不可见，因此也不能被重载。<br>结论：只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切的说，在导出类中，对于基类中的private方法，最好采用不同的名字。<br>思考：如果想达到期望输出，可以把基类中的f()方法改成public或者private，这样子类就可以覆盖。或者把子类中的f()方法改名，并且在主函数中重新调用即可。</p>
<h2 id="域与静态方法"><a href="#域与静态方法" class="headerlink" title="域与静态方法"></a>域与静态方法</h2><p>只有普通的方法调用是可以多态的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">    public int field = 0;</span><br><span class="line">    public int getField() &#123;return field;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Super &#123;</span><br><span class="line">    public int field = 1;</span><br><span class="line">    public int getField() &#123;return field;&#125;</span><br><span class="line">    public int getSupperField() &#123; return super.field;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FieldAccess &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super sup = new Sub();</span><br><span class="line">        System.out.println(&quot;sup.field = &quot; + sup.field + &quot;, sup.getField() = &quot; + sup.getField());</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        System.out.println(&quot;sub.field = &quot; + sub.field + &quot;, sub.getField() = &quot; + sub.getField() + &quot;, sub.getSupperFiled() = &quot; + sub.getSupperField());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sup.field = 0, sup.getField() = 1</span><br><span class="line">sub.field = 1, sub.getField() = 1, sub.getSupperFiled() = 0</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>在Java中，成员变量是静态绑定因为Java不允许对成员变量执行多态操作。<br>当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的（多态是在运行过程中进行动态绑定）。在这个例子中，虚拟机为Super.field和Sub.field分配了不同的存储空间(在堆内存中)。这样，Sub实际上包含两个称为field的域。然而，在引用Sub中的field时所产生的默认域并非Super版本的域。因此，为了得到Super.field，必须显示的指明super.field。<br>总结：<br>以上这种访问方法无疑是非常易混淆的，因此实际开发中通常会将所有的域都设置成private。</p>
<p>另外一种情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StaticSupper &#123;</span><br><span class="line">    public static String staticGet() &#123;</span><br><span class="line">        return &quot;Base staticGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String dynamicGet() &#123;</span><br><span class="line">        return &quot;Base dynamicGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StaticSub extends StaticSupper &#123;</span><br><span class="line">    public static String staticGet() &#123;</span><br><span class="line">        return &quot;Derived staticGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String dynamicGet() &#123;</span><br><span class="line">        return &quot;Derived dynamicGet()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StaticPolymorphism &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StaticSupper sup = new StaticSub();</span><br><span class="line">        System.out.println(sup.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base staticGet()</span><br><span class="line">Derived dynamicGet()</span><br></pre></td></tr></table></figure></p>
<p>分析：基类中的staticGet()方法是静态方法，dynamicGet是非静态方法，从结果中可以看出子类并没有覆盖基类中的静态方法。<br>总结：静态方法是与类，而并非与单个的对象相关联的。</p>
<h1 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h1><p>构造器不具有多态性，因为它们实际上是static方法，只不过该static声明式隐式的。</p>
<h2 id="构造器的调用顺序"><a href="#构造器的调用顺序" class="headerlink" title="构造器的调用顺序"></a>构造器的调用顺序</h2><p>基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Meal &#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(&quot;Meal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bread &#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(&quot;Bread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cheese &#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(&quot;Cheese&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lettuce &#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(&quot;Lettuce&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lunch extends Meal &#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(&quot;Lunch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PortableLunch extends Lunch &#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(&quot;PortableLunch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sandwich extends PortableLunch&#123;</span><br><span class="line">    Sandwich() &#123;</span><br><span class="line">        System.out.println(&quot;Sandwich&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private Bread b = new Bread();</span><br><span class="line">    private Cheese c = new Cheese();</span><br><span class="line">    private  Lettuce l = new Lettuce();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Meal</span><br><span class="line">Lunch</span><br><span class="line">PortableLunch</span><br><span class="line">Bread</span><br><span class="line">Cheese</span><br><span class="line">Lettuce</span><br><span class="line">Sandwich</span><br></pre></td></tr></table></figure></p>
<p>分析&amp;总结：从输出中验证结论，调用构造器要遵照下面的顺序：</p>
<ol>
<li>调用基类构造器。这个步骤会不断地反复地递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最低层的导出类。</li>
<li>按声明顺序调用成员的初始化方法。</li>
<li>调用导出类构造器的主体。</li>
</ol>
<hr>
<h4 id="Q-What-is-the-difference-between-compile-time-polymorphism-and-runtime-polymorphism"><a href="#Q-What-is-the-difference-between-compile-time-polymorphism-and-runtime-polymorphism" class="headerlink" title="Q. What is the difference between compile-time polymorphism and runtime polymorphism?"></a>Q. <strong><em>What is the difference between compile-time polymorphism and runtime polymorphism?</em></strong></h4><p>There are two types of polymorphism in java:<br>1) Static Polymorphism also known as compile time polymorphism<br>2) Dynamic Polymorphism also known as runtime polymorphism</p>
<p><strong>Example of static Polymorphism</strong>  </p>
<p>Method overloading is one of the way java supports static polymorphism. Here we have two definitions of the same method add() which add method would be called is determined by the parameter list at the compile time. That is the reason this is also known as compile time polymorphism.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCalculator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	   SimpleCalculator obj = <span class="keyword">new</span> SimpleCalculator();</span><br><span class="line">      System.out.println(obj.add(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">      System.out.println(obj.add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br><span class="line">60</span><br></pre></td></tr></table></figure></p>
<p><strong>Runtime Polymorphism (or Dynamic polymorphism)</strong>  </p>
<p>It is also known as Dynamic Method Dispatch. Dynamic polymorphism is a process in which a call to an overridden method is resolved at runtime, thats why it is called runtime polymorphism.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Overridden Method"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XYZ</span> <span class="keyword">extends</span> <span class="title">ABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Overriding Method"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">	ABC obj = <span class="keyword">new</span> XYZ();</span><br><span class="line">	obj.myMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Overriding Method</span><br></pre></td></tr></table></figure></p>
<h4 id="Q-Can-you-achieve-Runtime-Polymorphism-by-data-members"><a href="#Q-Can-you-achieve-Runtime-Polymorphism-by-data-members" class="headerlink" title="Q. Can you achieve Runtime Polymorphism by data members?"></a>Q. <strong><em>Can you achieve Runtime Polymorphism by data members?</em></strong></h4><p>No, we cannot achieve runtime polymorphism by data members. Method is overridden not the data members, so runtime polymorphism can’t be achieved by data members.</p>
<h4 id="Q-Overloading-vs-Overridden"><a href="#Q-Overloading-vs-Overridden" class="headerlink" title="Q. Overloading vs Overridden"></a>Q. <strong><em>Overloading vs Overridden</em></strong></h4><p>Overloading occurs when two or more methods in one class have the same method name but different parameters. Overriding means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
