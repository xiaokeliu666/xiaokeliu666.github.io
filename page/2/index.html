<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Feb 1997">
<meta property="og:url" content="http://xiaokeliu666.github.io/page/2/index.html">
<meta property="og:site_name" content="Feb 1997">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feb 1997">
  <link rel="canonical" href="http://xiaokeliu666.github.io/page/2/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Feb 1997</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Feb 1997</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Overtime and overdue</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/25/Java：protected提供访问权限/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/25/Java：protected提供访问权限/" class="post-title-link" itemprop="url">Java：protected提供包访问权限</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-25 21:29:28" itemprop="dateCreated datePublished" datetime="2019-08-25T21:29:28-04:00">2019-08-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 14:55:17" itemprop="dateModified" datetime="2019-08-29T14:55:17-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;Java类中的属性在不指定访问权限，即private、protected或者public的情况下被称为“默认访问模式”，该模式下，只允许在同一个包中访问。<br>&emsp;&emsp;当需要继承的类来自另外一个包(packet)时，如果父类中的方法是私有的或者是默认访问模式（即未指定的），那么子类是不能继承的,<br>父类代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package 01;</span><br><span class="line"></span><br><span class="line">public class Cookie &#123;</span><br><span class="line">    public Cookie()&#123;</span><br><span class="line">        System.out.println(&quot;Cookie constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void bite()&#123;</span><br><span class="line">        System.out.println(&quot;bite&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子类代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package 02;</span><br><span class="line">import 01.Cookie;  // 导入父类所在的包</span><br><span class="line"></span><br><span class="line">public class ChocolateChip extends Cookie&#123;</span><br><span class="line">    public ChocolateChip()&#123;</span><br><span class="line">        System.out.println(&quot;ChocolateChip constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void chomp()&#123;</span><br><span class="line">        bite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChocolateChip x = new ChocolateChip();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(9, 9) java: 找不到符号</span><br><span class="line">符号:   方法 bite()</span><br><span class="line">位置: 类 com.demo.xliu294.ChocolateChip</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;假设我们现在希望子类可以继承来自另外一个包的父类中的方法，可以将父类中的该方法设置为public或者protected，但是如果把它指定为public的话，所有的人都有了访问权限，这样是不合适的。但是如果改成protected的话，子类中的bite()就可以访问了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包中的public成员。（当然，如果在同一个包内执行继承工作，就可以操纵所有的拥有包访问权限的成员。）有时，基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。protected也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《Java编程思想》</p>
</blockquote>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/25/Java踩坑：初始化顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/25/Java踩坑：初始化顺序/" class="post-title-link" itemprop="url">Java踩坑：初始化顺序</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-25 15:21:00" itemprop="dateCreated datePublished" datetime="2019-08-25T15:21:00-04:00">2019-08-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-06 16:54:48" itemprop="dateModified" datetime="2019-09-06T16:54:48-04:00">2019-09-06</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>求以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Window &#123;</span><br><span class="line">    Window(int marker)&#123;</span><br><span class="line">        System.out.println(&quot;Window(&quot; + marker + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class House &#123;</span><br><span class="line">    Window w1 = new Window(1);</span><br><span class="line">    House()&#123;</span><br><span class="line">        System.out.println(&quot;House()&quot;);</span><br><span class="line">        w3 = new Window(33);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = new Window(2);</span><br><span class="line">    void f()&#123;</span><br><span class="line">        System.out.println(&quot;f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = new Window(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderOfInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        House h = new House();</span><br><span class="line">        h.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="错误答案"><a href="#错误答案" class="headerlink" title="错误答案"></a>错误答案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">House()</span><br><span class="line">Window(3)</span><br><span class="line">Window(33)</span><br><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<h2 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h2><p>从主函数出发创建一个House类对象h，构造函数会在创建对象的同时执行，找到House类的构造函数，先输出House()，因为w3是个没被声明的变量，所以先运行了<code>Window w3 = new Window(3)</code>输出Window(3)然后再完成构造函数，输出Window(33)，然后按照顺序完成以下输出。</p>
<h1 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">Window(3)</span><br><span class="line">House()</span><br><span class="line">Window(33)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。在House类中，故意把几个Window对象的定义散布到各处，以整明它们全都会在调用构造器或其他方法之前得到初始化。此外，w3在构造期内再次被初始化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在意识到如果构造函数先执行的话<code>w3 = new Window(33)</code>这一句中的w3是一个没有被声明的变量时就觉得不太对，但还是没有找出正确的思路。后来在尝试别的情况时把这一句注释掉了，输出顺序还是不变，只是少了一句Window(33)。</p>
<hr>
<h1 id="2019-09-06"><a href="#2019-09-06" class="headerlink" title="2019-09-06"></a>2019-09-06</h1><p>今天在学习多态的过程中又遇到了一个初始化顺序的问题，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Glyph &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Glyph.draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(&quot;Glyph() before draw()&quot;);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(&quot;Glyph() after draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RoundGlyph extends Glyph &#123;</span><br><span class="line">    private int radius = 1;</span><br><span class="line">    RoundGlyph(int r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(&quot;RoundGlyph.RoundGlyph().radius = &quot; + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;RoundGlyph.draw().radius = &quot; + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PolyConstructors &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new RoundGlyph(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw().radius = 1</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph.radius = 5</span><br></pre></td></tr></table></figure></p>
<p>错误思路：<br>首先调用基类构造器，考虑到新创建的对象是RoundGlyph()类的，我认为此处的draw()方法应该已经被覆盖，应该调用子类的draw方法，radius的值在子类中被初始化为1，因此得到了第二行的输出。最后再调用子类构造器的主体，输出第四行。<br>正确答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glyph() before draw()</span><br><span class="line">RoundGlyph.draw().radius = 0</span><br><span class="line">Glyph() after draw()</span><br><span class="line">RoundGlyph.RoundGlyph.radius = 5</span><br></pre></td></tr></table></figure></p>
<p>正确思路：除了第二行radius的值以外都对了。初始化的实际过程是：1）在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的0。2）如前所述那样调用基类构造器。此时，调用被覆盖后的draw()方法（需要在调用RoundGlyph构造器之前调用），由于步骤1的缘故，我们此时会发现radius的值为0。3）按照声明的顺序调用成员的初始化方法。4）调用导出类的构造器主体。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/24/Java：隔离岛/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/24/Java：隔离岛/" class="post-title-link" itemprop="url">Java：隔离岛</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-24 21:14:52" itemprop="dateCreated datePublished" datetime="2019-08-24T21:14:52-04:00">2019-08-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:04:26" itemprop="dateModified" datetime="2019-08-29T15:04:26-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在Java中，对象的销毁由GC(垃圾收集器)模块负责，并且那些没有被引用的对象是可以被垃圾收集的，垃圾收集器能够识别这类的对象。<br>&emsp;&emsp;隔离岛：<br>&emsp;&emsp;- 对象1引用对象2和对象2引用对象1.对象1和对象2都不被任何其他对象引用。<br>&emsp;&emsp;- 通常来说隔离岛是一组互相引用但不被应用程序中其它活动的对象引用的对象。严格来说，即使一个没有被引用的对象也是一个隔离岛。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    Test i;  // 类里定义了一个对象引用</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test t1 = new Test();</span><br><span class="line">        Test t2 = new Test();</span><br><span class="line"></span><br><span class="line">        t1.i = t2;</span><br><span class="line">        t2.i = t1;</span><br><span class="line">        t1 = null;</span><br><span class="line">        t2 = null;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable&#123;</span><br><span class="line">        System.out.println(&quot;Finalize method called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Finalize method called</span><br><span class="line">Finalize method called</span><br></pre></td></tr></table></figure></p>
<p>分析:<br>&emsp;&emsp;在销毁一个对象之前，垃圾收集器对一个对象最多调用一次finalize方法,在上例中finalize方法被调用两次的理由是因为两个对象都有资格被垃圾收集。这是因为我们在执行<code>t2=null</code>之后没有任何对t1和t2的外部引用。<br>&emsp;&emsp;我们只有内部的互相引用(在Test类的实例变量i中)。我们没有办法去调用两个对象的实例变量。所以不能再次调用任何一个对象。<br>&emsp;&emsp;我们在Test类里面创建了一个属性Test i，主函数中创建了两个Test类型的对象，并且用两个引用t1和t2去指向这两个对象，然后通过t1.i去访问t2，通过t2.i去访问t1，直到t2.i = t1: 每个对象都有外部引用t1和t2。这里需要记住的是t1和t2仅仅是引用，真正的对象在图中是以圈表示的,下图中t1指向一个对象，这个对象中有属性i，通过t1这个对象的属性i指向另一个对象，也就是t2指向的对象，反之亦然：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_1.png" alt><br>&emsp;&emsp;t1 = null: 此时引用t1已经不指向任何对象，但是对象还是存在的，只不过通过t2.i可以到达之前t1指向的对象，通过t2可以直接访问另一个对象：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_11.png" alt><br>&emsp;&emsp;t2 = null: 分析过程和上一步相同，此时没有办法到达任何一个对象：<br><img src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Untitled_12.png" alt><br>&emsp;&emsp;现在，两个对象都有资格被垃圾收集，因为我们没有办法调用他们了。这通常被称为隔离岛。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://www.geeksforgeeks.org/island-of-isolation-in-java/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
</blockquote>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/23/Java：GC机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/23/Java：GC机制/" class="post-title-link" itemprop="url">Java：GC机制</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-23 22:19:18" itemprop="dateCreated datePublished" datetime="2019-08-23T22:19:18-04:00">2019-08-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:03:35" itemprop="dateModified" datetime="2019-08-29T15:03:35-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在 C/C++中，编程者需要同时负责对象的创建与销毁。通常情况下编程者会忘记销毁无用的对象。由于这种忽视，在某个时间点可能会没有足够的内存空间去创建新的对象从而导致整个程序因为内存溢出而终止。</li>
<li>在Java中，编程者不需要关心哪个对象不会再被用上。垃圾收集器会销毁这些对象。</li>
<li>垃圾收集器是守护线程的最好例子因为它总是在后台运行。</li>
<li>垃圾收集器的主要目的是通过摧毁不可到达的对象从而释放内存堆。<h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2></li>
</ul>
<ol>
<li>不可到达的对象(Unreachable objects): 如果一个对象没有任何指向它的索引那么我们称之为不可到达的对象。同样注意到属于隔离岛一部分的对象也是不可到达的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(4);</span><br><span class="line">// 通过i中的索引，这个新的整型对象是可到达的</span><br><span class="line">i = null;</span><br><span class="line">// 那个整型对象不可到达了</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="//xiaokeliu666.github.io/2019/08/23/Java：GC机制/reference.png" alt="img"></p>
<ol>
<li>垃圾收集的合格性(Eligibility for garbage collection)：如果一个对象是不可到达的，那么就可以被垃圾收集。在上图中，在<code>i = null;</code>之后堆空间中的整型对象4就可以被垃圾收集了。</li>
</ol>
<h1 id="使对象可以被垃圾收集的方法"><a href="#使对象可以被垃圾收集的方法" class="headerlink" title="使对象可以被垃圾收集的方法"></a>使对象可以被垃圾收集的方法</h1><ul>
<li>即使编程者不需要负责摧毁无用的对象，但还是推荐把不再需要的对象变得不可到达。</li>
<li>通常有四种方法让对象变得可以被垃圾收集。<ol>
<li>让引用变量为空</li>
<li>重新分配引用变量</li>
<li>在方法内部创建对象</li>
<li>隔离岛</li>
</ol>
</li>
</ul>
<h1 id="请求JVM运行垃圾收集器的方法"><a href="#请求JVM运行垃圾收集器的方法" class="headerlink" title="请求JVM运行垃圾收集器的方法"></a>请求JVM运行垃圾收集器的方法</h1><ul>
<li>一旦我们让对象可以被垃圾收集，它可能不会立即被垃圾收集器销毁。无论何时JVM运行垃圾收集程序，只有对象会被销毁。但是当JVM运行垃圾收集器，我们不能预计。</li>
<li>我们也可以请求JVM运行垃圾收集器。有以下两种方法：<ol>
<li>使用<code>System.gc()</code>方法: System类包含静态方法gc()来请求JVM运行垃圾收集器。</li>
<li>使用<code>Runtime.getRuntime().gc()</code>方法： Runtime类允许应用程序与运行应用程序的JVM进行交互。于是通过使用它的<code>gc()</code>方法，我们可以请求JVM运行垃圾收集器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Java程序描述请求JVM去运行垃圾收集器</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        Test t1 = new Test();</span><br><span class="line">        Test t2 = new Test();</span><br><span class="line"></span><br><span class="line">        //让引用变量为空</span><br><span class="line">        t1 = null;</span><br><span class="line"></span><br><span class="line">        //请求JVM运行垃圾收集器</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        //让引用变量为空</span><br><span class="line">        t2 = null;</span><br><span class="line"></span><br><span class="line">        //请求JVM运行垃圾收集器</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    // finalize method is called on object once</span><br><span class="line">    // before garbage collecting it</span><br><span class="line">    protected void finalize() thorws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Garbage collector called&quot;);</span><br><span class="line">        System.out.println(&quot;Object garbage collected:&quot; + this);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ol>
<li>无法保证以上两种方式中的任何一种绝对会运行垃圾处理器。</li>
<li>调用两种方法在效率上是等价的。</li>
</ol>
<h1 id="Finalization"><a href="#Finalization" class="headerlink" title="Finalization"></a>Finalization</h1><ul>
<li>在销毁对象之前，垃圾收集器对对象调用finalize()方法来执行清理动作。一旦finalize()方法完成，垃圾收集器销毁对象。</li>
<li>fianlize()方法出现在Object类里，该方法的访问修饰符为protected，原型如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据我们的需求，我们可以重写finalize()方法来执行我们的清理动作比如关闭数据库的连接。</p>
<p>注意：</p>
<ol>
<li>finalize()是由垃圾收集器调用的而不是JVM。虽然垃圾收集器是JVM的一个模型。</li>
<li>Object类finalize()方法的执行为空，因此如果要部署系统资源或者执行其他清理的话需要重载这个方法。</li>
<li>finalize()方法不会对一个对象调用多次。</li>
<li>如果finalize()方法抛出了一个不可捕捉的异常，异常会被忽略而且对象的终结会被终止。</li>
</ol>
<h1 id="垃圾收集器的使用"><a href="#垃圾收集器的使用" class="headerlink" title="垃圾收集器的使用"></a>垃圾收集器的使用</h1><p>假设要写一个程序去计算公司中工作的员工数（除去实习生），你需要垃圾收集器来完成这个程序。<br>任务描述：<br>写一个程序创建一个叫做Employee的类包含以下的数据成员：</p>
<ol>
<li>ID，存储分配给每个员工的独一无二的id</li>
<li>员工的姓名</li>
<li>员工的年龄<br>同时提供以下方法：</li>
<li>一个带参构造函数用来初始化姓名和年龄，ID需要在构造器中被初始化</li>
<li>一个show()方法去展示ID,姓名和年龄</li>
<li>一个showNextId()去展示每个员工的下一个ID<br>作为一个没有垃圾收集器知识的初学者会这样写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private int ID;</span><br><span class="line">    private  String name;</span><br><span class="line">    private  int age;</span><br><span class="line">    private static int nextId=1;</span><br><span class="line"></span><br><span class="line">    public Employee(String name, int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.ID = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;Id=&quot;+ID+&quot;\nName=&quot;+name+&quot;\nAge=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void showNextId()&#123;</span><br><span class="line">        System.out.println(&quot;Next employee id of &quot;+ID&quot; will be=&quot;+nextId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Employee E = new Employee(&quot;GFG1&quot;, 56);</span><br><span class="line">        E.showNextId();</span><br><span class="line">        Employee F = new Employee(&quot;GFG2&quot;, 45);</span><br><span class="line">        F.showNextId();</span><br><span class="line">        Employee G = new Employee(&quot;GFG3&quot;, 25);</span><br><span class="line">        G.showNextId();                                </span><br><span class="line">        &#123;</span><br><span class="line">            //用块来保存实习生</span><br><span class="line">            Employee X = new Employee(&quot;GFG4&quot;, 23);</span><br><span class="line">            X.showNextId();</span><br><span class="line">            Employee Y = new Employee(&quot;GFG5&quot;, 21);</span><br><span class="line">            Y.showNextId();                               </span><br><span class="line">        &#125;</span><br><span class="line">        G.showNextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Next employee id of 1 will be=2</span><br><span class="line">Next employee id of 2 will be=3</span><br><span class="line">Next employee id of 3 will be=4</span><br><span class="line">Next employee id of 4 will be=5</span><br><span class="line">Next employee id of 5 will be=6</span><br><span class="line">Next employee id of 3 will be=6</span><br></pre></td></tr></table></figure></p>
<p>类的定义中nextId属性为静态，被所有对象共享。第一个G.showNextId()输出的是4，第二个G.showNextId()输出的是6。<br>如何获得获得正确的输出（即让第二个G.showNextId()输出4）：<br>现在垃圾收集器会看到两个空闲的对象，现在去减少nextId的值，垃圾收集器只有在编程者在类中重载的情况下才会调用方法finalize()。正如之前提到的，我们需要向垃圾收集器发起请求，我们要在子块的中写下一下三个步骤：</p>
<ol>
<li>将引用变量设为空</li>
<li>调用System.gc();</li>
<li>调用System.runFinalization();<br>现在计算员工（除了实习生）的正确代码是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private int ID;</span><br><span class="line">    private  String name;</span><br><span class="line">    private  int age;</span><br><span class="line">    private static int nextId=1;</span><br><span class="line"></span><br><span class="line">    public Employee(String name, int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.ID = nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;Id=&quot;+ID+&quot;\nName=&quot;+name+&quot;\nAge=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void showNextId()&#123;</span><br><span class="line">        System.out.println(&quot;Next employee id of &quot;+ID&quot; will be=&quot;+nextId);</span><br><span class="line">    &#125;</span><br><span class="line">    // 供gc调用</span><br><span class="line">    protected void finalize()&#123;</span><br><span class="line">    --nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Employee E = new Employee(&quot;GFG1&quot;, 56);</span><br><span class="line">        E.showNextId();</span><br><span class="line">        Employee F = new Employee(&quot;GFG2&quot;, 45);</span><br><span class="line">        F.showNextId();</span><br><span class="line">        Employee G = new Employee(&quot;GFG3&quot;, 25);</span><br><span class="line">        G.showNextId();                                </span><br><span class="line">        &#123;</span><br><span class="line">            //用块来保存实习生</span><br><span class="line">            Employee X = new Employee(&quot;GFG4&quot;, 23);</span><br><span class="line">            X.showNextId();</span><br><span class="line">            Employee Y = new Employee(&quot;GFG5&quot;, 21);</span><br><span class="line">            Y.showNextId();  </span><br><span class="line">            X = Y = null;  // 设置为空</span><br><span class="line">            System.gc();  //调用垃圾收集器</span><br><span class="line">            System.runFinalization();     // 执行finalize                         </span><br><span class="line">        &#125;</span><br><span class="line">        G.showNextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Next employee id of 1 will be=2</span><br><span class="line">Next employee id of 2 will be=3</span><br><span class="line">Next employee id of 3 will be=4</span><br><span class="line">Next employee id of 4 will be=5</span><br><span class="line">Next employee id of 5 will be=6</span><br><span class="line">Next employee id of 3 will be=4</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://www.geeksforgeeks.org/garbage-collection-java/" target="_blank" rel="noopener">GeeksforGeeks</a></p>
</blockquote>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/21/Java：Static关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/21/Java：Static关键字/" class="post-title-link" itemprop="url">Java：Static关键字</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-21 22:26:08" itemprop="dateCreated datePublished" datetime="2019-08-21T22:26:08-04:00">2019-08-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 14:55:40" itemprop="dateModified" datetime="2019-08-29T14:55:40-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Static介绍与用法"><a href="#Static介绍与用法" class="headerlink" title="Static介绍与用法"></a>Static介绍与用法</h1><p>&emsp;&emsp;通常来说，当创建类时，就是在描述那个类的对象的外观与行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。<br>&emsp;&emsp;有两种情形用上述方法是无解的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能调用这个方法。<br>&emsp;&emsp;通过static关键字可以满足这两方面的需要。当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的对任何对象，也可以调用其static方法或访问其static域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非static域和方法必须知道他们一起运作的特定对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line">    static int i = 47;</span><br><span class="line">    int j = 47;</span><br><span class="line">    static void incrementi()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    void incrementj()&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        StaticTest st1 = new StaticTest();</span><br><span class="line">        StaticTest st2 = new StaticTest();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;st1.i: &quot; + st1.i);</span><br><span class="line">        System.out.println(&quot;st2.i: &quot; + st2.i);</span><br><span class="line"></span><br><span class="line">        st1.incrementi();</span><br><span class="line">        System.out.println(&quot;st1.incrementi()后的st1.i: &quot; + st1.i);</span><br><span class="line">        System.out.println(&quot;st1.incrementi()后的st2.i: &quot; + st2.i);</span><br><span class="line"></span><br><span class="line">        st1.incrementj();</span><br><span class="line">        System.out.println(&quot;st1.incrementj()后的st1.j: &quot; + st1.j);</span><br><span class="line">        System.out.println(&quot;st1.incrementj()后的st2.j: &quot; + st2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Output:</span><br><span class="line">st1.i: 47</span><br><span class="line">st2.i: 47</span><br><span class="line">st1.incrementi()后的st1.i: 48</span><br><span class="line">st1.incrementi()后的st2.i: 48</span><br><span class="line">st1.incrementj()后的st1.j: 48</span><br><span class="line">st1.incrementj()后的st2.j: 47</span><br></pre></td></tr></table></figure></p>
<p>以上代码中i是静态变量，incrementi()是静态方法。创建两个对象并且只对其中一个执行incrementi()方法得出的输出中，两个对象的i属性都加了1。incrementj()不是静态方法，所以st1执行incrementj()后，st2的j值不变。</p>
<p>&emsp;&emsp;将字段或方法设定为static，即使创建了两个StaticTest对象，StaticTest.i也只有一份存储空间，这两个对象公像一个i，上例中的st1.i和st2.j指向同一存储空间。</p>
<p>引用static对象时可以通过类名直接引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticTest.i++</span><br></pre></td></tr></table></figure></p>
<p>或者因为incrementi()是一个静态方法，也可以直接通过类调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticTest.incrementi()</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;尽管当static作用于某个字段时，肯定会改变数据创建的方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间），但是如果static作用于某个方法，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它，这一点对定义main()方法很重要，这个方法是运行一个应用时的一个入口点。</p>
<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>&emsp;&emsp;对于Static的理解我个人认为重点是认识到Static的字段，不管创建多少个对象，字段都是指向同一个存储空间，也就是说都是同时改变的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《JAVA编程思想第四版》</p>
</blockquote>
<hr>
<p>Q:为什么main函数中不能定义static变量？<br>A:只有类才存在静态的变量，方法只能对静态变量的操作，不能在方法内试图定义静态变量。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/19/Django：模型访问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/19/Django：模型访问/" class="post-title-link" itemprop="url">Django：模型访问</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-19 17:27:05" itemprop="dateCreated datePublished" datetime="2019-08-19T17:27:05-04:00">2019-08-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:12:52" itemprop="dateModified" datetime="2019-08-29T15:12:52-04:00">2019-08-29</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Manager属性"><a href="#Manager属性" class="headerlink" title="Manager属性"></a>Manager属性</h1><p>&emsp;&emsp;Manager是Django模型最重要的属性，通过使用Manager模型才可以操作数据库。默认情况下，Django会为每一个模型提供一个名为objects的Manager实例。Manager属性只能通过模型类访问。</p>
<h2 id="自定义Manager类"><a href="#自定义Manager类" class="headerlink" title="自定义Manager类"></a>自定义Manager类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Blog(models.Model):</span><br><span class="line">&apos;&apos;&apos;模型的定义&apos;&apos;&apos;</span><br><span class="line">    name = models.CharField(max_length=100)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line">    blog = models.Manager()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure>
<p>上例中的<code>blog = models.Manager()</code>自定义Manager类(之前的情况是不加这一句的)，可以通过<code>Blog.blog.all()</code>查询数据，返回的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Scott Blog&gt;]&gt;</span><br></pre></td></tr></table></figure></p>
<p>改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qs = Blog.blog.all()</span><br><span class="line">for b in qs:</span><br><span class="line">    print(b.name)</span><br></pre></td></tr></table></figure></p>
<p>返回的结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Beatles Blog</span><br><span class="line">Scott Blog</span><br></pre></td></tr></table></figure></p>
<h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><ol>
<li>Manager.raw()<br>语法：Manager.raw(raw_query, params=None, translations=None)<br>针对同样的Blog模型<br>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blogs = Blog.blog.raw(&quot;select * from tst_blog&quot;)  # 第一个blog是我在模型中将Manager()命名为blog，tst_blog是表</span><br><span class="line">for b in blogs:</span><br><span class="line">    print(b.name)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Beatles Blog</span><br><span class="line">Scott Blog</span><br></pre></td></tr></table></figure></p>
<p>注意：如果不能返回数据则会抛出异常</p>
<ol>
<li>django.db.connection<br>&emsp;&emsp;django.db.connection对象提供了数据库连接操作，使用connection.cursor()方法可以得到一个游标对象，cursor.execute(sql,[paramas])方法用于执行指定的SQL语句。使用cursor.fetchone()或者cursor.fetchall()方法可以得到一个或全部结果。<h1 id="表与表之间的关系"><a href="#表与表之间的关系" class="headerlink" title="表与表之间的关系"></a>表与表之间的关系</h1><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2>&emsp;&emsp;在关系型数据库中通常使用外键来表示多对一关系，Django模型中的ForeignKey字段就是模型的外键，写在“多”的那个模型下，其第一个参数对应相关联的类，例如一个问题可以有多个选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Question(models.Model):</span><br><span class="line">    content = models.CharField(max_length=128)</span><br><span class="line"></span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)  # on_delete=models.CASCADE属性必须设置，表示级联删除</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;以上代码在生成数据库时，Django会自动在Choice所对应的表中添加字段question_id作为外键。<br><strong>访问方法：</strong><br>前向查询：通过 Choice中的外键查询Question<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = Choice.objects.get(pk=1)</span><br><span class="line">c.question</span><br></pre></td></tr></table></figure></p>
<p>反向查询：通过Question查询Choice<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q = Question.objects.get(pk=1)</span><br><span class="line">q.choice_set.all()</span><br></pre></td></tr></table></figure></p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>&emsp;&emsp;假设公司里一个员工属于一个或多个部门，每个部门有一个或多个员工，为了实现该组织架构，使用ManyToManyField字段类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Department(models.Model):</span><br><span class="line">    name = models.CharField(max_length=50)</span><br><span class="line"></span><br><span class="line">class Employee(models.Model):</span><br><span class="line">    departments = models.ManyToManyField(Department)  # 多对多字段名用复数</span><br><span class="line">    name = models.CharField(max_length=50)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意：可以在任一个模型中定义ManyToManyField，但是不能两个都定义。<br>对于多对多关系，Django会在数据库中额外创建一张关系表，关系表的命名规则是：应用程序名_模型1名_模型2名s，在上例中生成的表名为app_employee_departments<br>访问方法（类似反向查询）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = Department.objects.get(id=3)</span><br><span class="line">d.Employee_set.all()</span><br></pre></td></tr></table></figure></p>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>&emsp;&emsp;使用OneToOneField表示一对一关系，第一个参数是模型名。这种关系用的少。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/16/官方文档：Django-shortcut-functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/16/官方文档：Django-shortcut-functions/" class="post-title-link" itemprop="url">官方文档：Django shortcut functions</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-16 21:38:33" itemprop="dateCreated datePublished" datetime="2019-08-16T21:38:33-04:00">2019-08-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:12:33" itemprop="dateModified" datetime="2019-08-29T15:12:33-04:00">2019-08-29</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>django.shortcuts包整合了“跨越”MVC中很多层的方法和类。</p>
<h1 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(request,template_name,context=None,content_type=None,status=None,using=None)</span><br></pre></td></tr></table></figure>
<p>将一个已有的模板和一个已有的字典结合起来并且返回一个带有被渲染的文本的HttpResponse对象。<br>Django不提供返回TemplateResponse的快捷方式因为render()和TemplateResponse的构造器一样方便。</p>
<h2 id="必须参数"><a href="#必须参数" class="headerlink" title="必须参数"></a>必须参数</h2><ol>
<li>request<br>&emsp;&emsp;用来生成这个response的request对象。</li>
<li>template_name<br>&emsp;&emsp;要使用的模板或模板序列的全名。如果给了一个序列，那么将会使用第一个已存在的模板。</li>
</ol>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><ol>
<li>context<br>&emsp;&emsp;一个字典，里面的值被加入模板文本中。默认情况下这是一个空字典。如果字典中的值是可调用的，视图会在渲染模板之前调用它。</li>
<li>context_type<br>&emsp;&emsp;The MIME type to use for the resulting document. Defaults to the value of the DEFAULT_CONTENT_TYPE setting.</li>
<li>status<br>&emsp;&emsp;响应状态码，默认为200。</li>
<li>using<br>&emsp;&emsp;用来加载模板的模板引擎的名字。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/14/Django踩坑：数据迁移遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/14/Django踩坑：数据迁移遇到的问题/" class="post-title-link" itemprop="url">Django踩坑：数据迁移遇到的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-14 22:43:46" itemprop="dateCreated datePublished" datetime="2019-08-14T22:43:46-04:00">2019-08-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 15:12:10" itemprop="dateModified" datetime="2019-08-29T15:12:10-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>&emsp;&emsp;在学习过程中我在同一个APP（名为’tst’）下反复修改模型（注释旧的模型，创建新的模型），在创建新模型后尝试进行数据迁移，出现如下错误信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No migrations to apply</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在尝试从数据库中删除所有与tst相关的字段后再次尝试迁移：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1050, &quot;Table &apos;django_content_type&apos; already exists&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>&emsp;&emsp;造成多次应用migrations失败的原因是，当前model是修改过的，原来的migrations已经被我删除，但是，重新生成的migrations使用递增整数记名，所以，在django_migrations表中0001，0002等前面几个数字的文件都已被记录，在Django看来，被记录了就相当于已应用，所以，会出现刚开始的No migrations to apply.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>&emsp;&emsp;python manage.py migrate —fake-initial<br>&emsp;&emsp;python manage.py makemigrations<br>&emsp;&emsp;python manage.py migrate</p>
<h1 id="关于—fake-initial和—fake"><a href="#关于—fake-initial和—fake" class="headerlink" title="关于—fake-initial和—fake"></a>关于—fake-initial和—fake</h1><h2 id="—fake-initial"><a href="#—fake-initial" class="headerlink" title="—fake-initial"></a>—fake-initial</h2><p>Allows Django to skip an app’s initial migration if all database tables with the names of all models created by all CreateModel operations in that migration already exist. This option is intended for use when first running migrations against a database that preexisted the use of migrations. This option does not, however, check for matching database schema beyond matching table names and so is only safe to use if you are confident that your existing schema matches what is recorded in your initial migration.</p>
<h2 id="—fake"><a href="#—fake" class="headerlink" title="—fake"></a>—fake</h2><p>Marks the migrations up to the target one (following the rules above) as applied, but without actually running the SQL to change your database schema.</p>
<p>This is intended for advanced users to manipulate the current migration state directly if they’re manually applying changes; be warned that using —fake runs the risk of putting the migration state table into a state where manual recovery will be needed to make migrations run correctly.</p>
<h1 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h1><blockquote>
<p><a href="https://blog.csdn.net/qq_25730711/article/details/60327344" target="_blank" rel="noopener">cdsn</a><br><a href="https://docs.djangoproject.com/en/2.2/topics/migrations/" target="_blank" rel="noopener">Django2.0官方文档</a></p>
</blockquote>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/13/（译）related_name in models.py/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/13/（译）related_name in models.py/" class="post-title-link" itemprop="url">（译）"related_name" in models.py</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-13 12:42:56" itemprop="dateCreated datePublished" datetime="2019-08-13T12:42:56-04:00">2019-08-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 14:48:56" itemprop="dateModified" datetime="2019-08-29T14:48:56-04:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>&emsp;&emsp;假设你有一个叫Book的模型和一个叫Category的模型。每本书只属于一个分类，用一个外键表示。因此你的模型设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Category(models.Model):</span><br><span class="line">    name = models.CharFeild(max_length=128)</span><br><span class="line"></span><br><span class="line">class Book(modesl.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果你有一个Book实例，你可以通过对应的field访问它的分类。并且，如果你有一个分类的实例，默认情况下Django会添加一个叫做”book_set”的属性，这个属性返回该分类下所有书的集合，因此可以进行如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from tst.models import Category, Book</span><br><span class="line">category = Category.objects.get(pk=1)</span><br><span class="line">print(&quot;Books in &quot;+category.name)</span><br><span class="line">for book in category.book_set.all():</span><br><span class="line">    print(book.name)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;book_set是一个django默认给我们构造的属性，通过外键的related_name属性可以给这个属性换个名字，比如说如果用<code>category = models.ForeighKey(Category, related_name=&#39;book_collection&#39;)</code>定义一个分类，我可以用<code>category.book_collection.all()</code>而不是<code>category.book_set.all()</code>。<br>&emsp;&emsp;大多数情况下都不需要修改related_name，而且django默认的x_set很好记。然而有一种情况下必须要用related_name：当你有多个从一个模型到另一个模型的外键时。这种情况下可能会产生冲突（因为django会尝试给同一个模型创建两个x_set属性）。<br>&emsp;&emsp;例如，如果我的Book模型如下（有一个分类和一个子分类）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category)</span><br><span class="line">    sub_category = models.ForeignKey(Category)</span><br></pre></td></tr></table></figure></p>
<p>于是模型不会生效除非你给一个（或两个）外键related_name属性，因此冲突就解决了。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Books(models.Model):</span><br><span class="line">    name = models.CharField(max_length=128)</span><br><span class="line">    category = models.ForeignKey(Category, related_name=&apos;book_category_set&apos;)</span><br><span class="line">    sub_category = models.ForeignKey(Category, related_name=&apos;book_sub_category_set&apos;)</span><br></pre></td></tr></table></figure></p>
<h1 id="原文连接"><a href="#原文连接" class="headerlink" title="原文连接"></a>原文连接</h1><p><a href="https://www.reddit.com/r/django/comments/76a7uw/related_name_in_modelspy/" target="_blank" rel="noopener">Reddit</a></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiaokeliu666.github.io/2019/08/12/Django学习笔记：模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feb 1997">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feb 1997">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/12/Django学习笔记：模型/" class="post-title-link" itemprop="url">Django学习笔记：模型搭建</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 23:01:40" itemprop="dateCreated datePublished" datetime="2019-08-12T23:01:40-04:00">2019-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-20 23:04:11" itemprop="dateModified" datetime="2019-08-20T23:04:11-04:00">2019-08-20</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>&emsp;&emsp;模型是一个用于表示数据的Python类，包含基本的数据字段和行为，在Django中，通常一个模型就代表一个数据库表。模型继承自django.db.models.Model, 模型的每一个属性代表一个数据表的列。<br>&emsp;&emsp;例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Person(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=30)</span><br><span class="line">    last_name = models.CharField(max_length=30)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是django根据模型所属应用程序生成数据库表明，命名规则：<strong>应用程序名_模型名</strong>，Django会自动添加id字段作为数据库表的主键。</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>&emsp;&emsp;个人对模型部分的理解是对数据库的操作，models.py文件中的所有操作都可以找到与之对应的数据库操作，只不过有特有的字段名称。而在编辑好模型后进行的数据迁移操作实际上就是将models.py里面的翻译成脚本，然后通过执行脚本文件对数据库进行操作从而生成当前APP所需要用到的数据库。</p>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>&emsp;&emsp;字段是一系列数据表列的定义。字段名字中不能出现连续的两个下划线，因为连续的两个下划线是Django数据库API的特殊语法。</p>
<h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><ol>
<li>AutoField<br>根据已有的ID自动增长，常用作主键，一般情况下会自动创建。</li>
<li>BooleanField<br>字段值只包含True和False，默认情况下对应HTML的复选框：<input type="checkbox" ...></li>
<li>CharField<br>保存不太长的字符串（超长字段建议使用TextField）。必须给出CharField.max_length属性值，默认情况下对应HTML的文本框：<input type="text" ...>。</li>
<li>DateField<br>日期类型，对应Python中的datetime.date类型。参数有：<br>auto_now:每当保存数据(Save())时都会更新时间为当前时间且不能被重写。<br>auto_now_add: 只有在数据第一次创建时才会保存当前时间且不能被重写。</li>
<li>DateTimeField<br>日期时间类型，对应Python中的datetime.datetime类型，参数与DateField一样。默认情况下对应HTML的复选框：<input type="checkbox" ...>。</li>
<li>EmailField<br>可以验证有效邮件地址的CharField。</li>
<li>FileField<br>文件上传控件，可选参数：<br>upload_to：文件上传后保存位置（在settings.py中设置MEDIA_ROOT,upload_to所指定的路径会拼接在MEDIA_ROOT之后）<br>storage：负责文件存储的Python类，用于存储和提取文件。</li>
<li>ImageField<br>包含FileField的全部属性与方法，但是仅允许上传图片类型的文件，额外两个可选属性:<br>height_field: 高度<br>width_field: 宽度</li>
<li>TextField<br>超长文本类型</li>
<li>URLField<br>只接受URL字符串的CharField类型。</li>
</ol>
<h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><ol>
<li>null<br>&emsp;&emsp;默认为True，保存模型后数据库的对应字段中保存空。<br>&emsp;&emsp;文本型字段尽可能不用null属性，因为当时用默认值null时，数据库中就可能出现两种空数据：NULL和空字符串，而Django默认使用空字符串。</li>
<li>blank<br>默认值为False，当设置为True时字段值允许为空</li>
<li><p>choices<br>属性值为一个<strong>可迭代对象</strong>，如列表或元组，迭代对象的每个成员包括两个字符串，第一个值作为字段值保存到数据库中，第二个值用于提高字段的可读性。例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">YEAR_IN_SCHOOL_CHOIECES = (</span><br><span class="line">    (&apos;FR&apos;, &apos;Freshman&apos;),</span><br><span class="line">    (&apos;SO&apos;, &apos;Sophomore&apos;),</span><br><span class="line">    (&apos;JR&apos;, &apos;Junior&apos;),</span><br><span class="line">    (&apos;SR&apos;, &apos;Senior&apos;),</span><br><span class="line">)  # 定义一个元组</span><br><span class="line"></span><br><span class="line">year_in_school = models.CharField(</span><br><span class="line">    max_length = 2,</span><br><span class="line">    choices = YEAR_IN_SCHOOL_CHOICES,  # 直接引用元组</span><br><span class="line">    default = &apos;Freshman&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>default<br>设置字段默认值。属性值可以是字符串也可以是方法。默认值<strong>不可以是可变对象</strong>，如列表。</p>
</li>
<li>primary_key<br>将字段设置为数据表主键。如果模型中任何字段都不包含primary_key=True属性，会自动添加一个字段作为主键。</li>
<li>verbose_name<br>类似于字段的说明。<br>除了ForeignKey、ManyToManyField、OneToOneField三种字段类型外，其他字段类型都包含一个默认的verbose_name属性，可以直接在字段属性列表的第一位输入文本作为verbose_name属性值，如未给出则会将字段名作为verbose_name（字段名如果包含下划线会换成空格）。<h2 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h2>模型对应数据库的表，那么字段就对应表的列。</li>
</ol>
<h1 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h1><p>通过在模型中添加一个叫做Meta的子类定义。</p>
<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p><code>abstract = True</code>，当前模型将成为一个抽象类。</p>
<h2 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h2><p>该属性是一个元组、列表或者查询表达式。定义了显示的顺序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;模型的构建对应数据库的构建，这次只记录了目前为止用过的一些知识，还有很多字段、属性、元属性尚未涉及，以后碰到了再继续补充。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="Feb 1997">
  <p class="site-author-name" itemprop="name">Feb 1997</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feb 1997</span>
</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/affix.js?v=7.2.0"></script>
  <script src="/js/schemes/pisces.js?v=7.2.0"></script>


  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  





  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
































</body>
</html>
